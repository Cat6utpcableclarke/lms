package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.71

import (
	"context"
	"fine_service/graph/model"
    "github.com/google/uuid"
    amqp "github.com/rabbitmq/amqp091-go"
	"fmt"
	"log"
	"time"
)

func (r *mutationResolver) CreateFine(ctx context.Context, patronID string, bookID string, ratePerDay float64) (*model.Fine, error) {
	// 1. Generate fine details
	fineID := uuid.NewString()
	createdAt := time.Now()
	daysLate := 5 // Replace with actual logic if needed
	amount := ratePerDay * float64(daysLate)

	// 2. Create the fine object
	fine := &model.Fine{
		FineID:     fineID,
		PatronID:   patronID,
		BookID:     bookID,
		DaysLate:   int32(daysLate),
		RatePerDay: ratePerDay,
		Amount:     amount,
		CreatedAt:  createdAt.Format(time.RFC3339),
	}

	// 3. Send message to RabbitMQ (if available)
	if r.Resolver.Rabbit != nil {
		message := fmt.Sprintf(`{
			"fine_id": "%s",
			"patron_id": "%s",
			"book_id": "%s",
			"amount": %.2f,
			"created_at": "%s"
		}`, fine.FineID, fine.PatronID, fine.BookID, fine.Amount, fine.CreatedAt)

		err := r.Resolver.Rabbit.Publish(
			"", // default exchange
			"fine_created_queue", // queue name as routing key
			false,
			false,
			amqp.Publishing{
				ContentType: "application/json",
				Body:        []byte(message),
			},
		)
		if err != nil {
			log.Printf("üêá Failed to publish to RabbitMQ: %v", err)
			// Optionally: return error or log only
		}
	}

	// 4. Return the created fine
	return fine, nil
}


// UpdateFine Resolver
func (r *mutationResolver) UpdateFine(ctx context.Context, fineID string, daysLate int32, ratePerDay float64) (*model.Fine, error) {
	// Fix: casting daysLate to float64 for multiplication
	amount := float64(daysLate) * ratePerDay

	query := `
		UPDATE fines
		SET days_late = $1, rate_per_day = $2, amount = $3
		WHERE fine_id = $4
		RETURNING patron_id, book_id, created_at
	`
	var patronID, bookID string
	var createdAt time.Time
	err := r.DB.QueryRowContext(ctx, query, daysLate, ratePerDay, amount, fineID).
		Scan(&patronID, &bookID, &createdAt)
	if err != nil {
		return nil, fmt.Errorf("failed to update fine: %w", err)
	}

	// Fix: casting daysLate to int32 in the struct
	return &model.Fine{
		FineID:     fineID,
		PatronID:   patronID,
		BookID:     bookID,
		DaysLate:   daysLate,
		RatePerDay: ratePerDay,
		Amount:     amount,
		CreatedAt:  createdAt.Format(time.RFC3339),
	}, nil
}

// DeleteFine is the resolver for the deleteFine field.
func (r *mutationResolver) DeleteFine(ctx context.Context, fineID string) (bool, error) {
	query := `
		DELETE FROM fines
		WHERE fine_id = $1
	`
	_, err := r.DB.ExecContext(ctx, query, fineID)
	if err != nil {
		return false, fmt.Errorf("failed to delete fine: %w", err)
	}

	return true, nil
}

// Query Resolver
func (r *queryResolver) GetFine(ctx context.Context, fineID string) (*model.Fine, error) {
	var fine model.Fine

	query := `
		SELECT fine_id, patron_id, book_id, days_late, rate_per_day, amount, created_at
		FROM fines
		WHERE fine_id = $1
	`
	row := r.DB.QueryRowContext(ctx, query, fineID)
	var createdAt time.Time
	err := row.Scan(
		&fine.FineID,
		&fine.PatronID,
		&fine.BookID,
		&fine.DaysLate,
		&fine.RatePerDay,
		&fine.Amount,
		&createdAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch fine: %w", err)
	}

	fine.CreatedAt = createdAt.Format(time.RFC3339)

	return &fine, nil
}

// ListFines is the resolver for the listFines field.
func (r *queryResolver) ListFines(ctx context.Context) ([]*model.Fine, error) {
	query := `
		SELECT fine_id, patron_id, book_id, days_late, rate_per_day, amount, created_at
		FROM fines
	`
	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to list fines: %w", err)
	}
	defer rows.Close()

	var fines []*model.Fine

	for rows.Next() {
		var fine model.Fine
		var createdAt time.Time
		err := rows.Scan(
			&fine.FineID,
			&fine.PatronID,
			&fine.BookID,
			&fine.DaysLate,
			&fine.RatePerDay,
			&fine.Amount,
			&createdAt,
		)
		if err != nil {
			return nil, err
		}
		fine.CreatedAt = createdAt.Format(time.RFC3339)
		fines = append(fines, &fine)
	}

	return fines, nil
}

// FineCreated is the resolver for the fineCreated field.
func (r *subscriptionResolver) FineCreated(ctx context.Context) (<-chan *model.Fine, error) {
	ch := make(chan *model.Fine, 1)

	r.FineCreatedSubscribers = append(r.FineCreatedSubscribers, ch)

	go func() {
		<-ctx.Done() // When the client disconnects
		// Remove the channel from subscribers
		for i, subscriber := range r.FineCreatedSubscribers {
			if subscriber == ch {
				r.FineCreatedSubscribers = append(r.FineCreatedSubscribers[:i], r.FineCreatedSubscribers[i+1:]...)
				break
			}
		}
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

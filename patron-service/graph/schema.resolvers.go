package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"strings"

	"github.com/GSalise/lms/patron-service/graph/model"
)

// CreatePatron is the resolver for the createPatron field.
func (r *mutationResolver) CreatePatron(ctx context.Context, firstName string, lastName string, phoneNumber string) (*model.Patron, error) {
	var patron model.Patron
	var membership model.Membership
	var patron_status model.PatronStatus
	var violations []*model.ViolationRecord

	// Note: add a condition that will only allow the correct regex for phone_number - front end na bahala ana kapoy

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	PatronErr := tx.QueryRow(ctx, `
		INSERT INTO patrons (first_name, last_name, phone_number)
		VALUES ($1,$2,$3)
		RETURNING patron_id, first_name, last_name, phone_number, patron_created::text
	`, firstName, lastName, phoneNumber).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if PatronErr != nil {
		return nil, fmt.Errorf("failed to insert patron: %v", PatronErr)
	}

	MembershipErr := tx.QueryRow(ctx, `
		INSERT INTO memberships (patron_id)
		VALUES($1)
		RETURNING membership_id, level
	`, patron.PatronID).Scan(
		&membership.MembershipID,
		&membership.Level,
	)

	if MembershipErr != nil {
		return nil, fmt.Errorf("failed to insert membership: %v", MembershipErr)
	}

	patron.Membership = &membership
	membership.PatronID = patron.PatronID

	PStatusErr := tx.QueryRow(ctx, `
		INSERT INTO patron_status (patron_id)
		VALUES($1)
		RETURNING warning_count, patron_status, unpaid_fees 
	`, patron.PatronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	if PStatusErr != nil {
		return nil, fmt.Errorf("failed to insert patron_status: %v", PStatusErr)
	}

	patron.Status = &patron_status
	patron_status.PatronID = patron.PatronID

	violationRows, violationErr := tx.Query(ctx, `
		SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
		FROM violation_records
		WHERE patron_id = $1
	`, patron.PatronID)

	if violationErr != nil {
		return nil, fmt.Errorf("failed to get violations: %v", violationErr)
	}

	defer violationRows.Close()

	for violationRows.Next() {
		var violation model.ViolationRecord
		err := violationRows.Scan(
			&violation.ViolationRecordID,
			&violation.ViolationType,
			&violation.ViolationInfo,
			&violation.ViolationCreated,
			&violation.ViolationStatus,
		)

		if err != nil {
			return nil, fmt.Errorf("failed scanning violation: %v", err)
		}
		violation.PatronID = patron.PatronID
		violations = append(violations, &violation)
	}

	patron.Violations = violations

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	patronCopy := patron

	r.SubscribersMutex.Lock()
	for subscriber := range r.PatronSubscribers {
		select {
		case subscriber <- &patronCopy:
			// No action needed
		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", patron.PatronID)
		}
	}
	r.SubscribersMutex.Unlock()

	return &patron, nil
}

// UpdatePatron is the resolver for the updatePatron field.
func (r *mutationResolver) UpdatePatron(ctx context.Context, patronID string, firstName *string, lastName *string, phoneNumber *string) (*model.Patron, error) {
	var patron model.Patron
	var membership model.Membership
	var patron_status model.PatronStatus
	var violations []*model.ViolationRecord

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	var exists bool
	err := tx.QueryRow(ctx, `
        SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
    `, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	if firstName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET first_name = $1
			WHERE patron_id = $2
		`, firstName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating first_name: %v", InsertErr)
		}
	}

	if lastName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET last_name = $1
			WHERE patron_id = $2
		`, lastName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating last_name: %v", InsertErr)
		}
	}

	// Note: add a condition that will only allow the correct regex for phone_number

	if phoneNumber != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET phone_number = $1
			WHERE patron_id = $2
		`, phoneNumber, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating phone_number: %v", InsertErr)
		}
	}

	FinalErr := tx.QueryRow(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if FinalErr != nil {
		return nil, fmt.Errorf("failed to update patron: %v", FinalErr)
	} else {
		MembershipErr := tx.QueryRow(ctx, `
			SELECT membership_id, level
			FROM memberships
			WHERE patron_id = $1
		`, patron.PatronID).Scan(
			&membership.MembershipID,
			&membership.Level,
		)

		if MembershipErr != nil {
			return nil, fmt.Errorf("failed to fetch membership: %v", MembershipErr)
		}

		patron.Membership = &membership
		membership.PatronID = patron.PatronID

		PStatusErr := tx.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

		violationRows, violationErr := tx.Query(ctx, `
		SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
		FROM violation_records
		WHERE patron_id = $1
		`, patronID)

		if violationErr != nil {
			return nil, fmt.Errorf("failed to get violations: %v", violationErr)
		}

		defer violationRows.Close()

		for violationRows.Next() {
			var violation model.ViolationRecord
			err := violationRows.Scan(
				&violation.ViolationRecordID,
				&violation.ViolationType,
				&violation.ViolationInfo,
				&violation.ViolationCreated,
				&violation.ViolationStatus,
			)

			if err != nil {
				return nil, fmt.Errorf("failed scanning violation: %v", err)
			}
			violation.PatronID = patronID
			violations = append(violations, &violation)
		}

		patron.Violations = violations

	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &patron, nil
}

// DeletePatronByID is the resolver for the deletePatronById field.
func (r *mutationResolver) DeletePatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron
	var membership model.Membership
	var patron_status model.PatronStatus
	var violations []*model.ViolationRecord

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	err := tx.QueryRow(ctx, `
        SELECT patron_id, first_name, last_name, phone_number, patron_created::text
        FROM patrons 
        WHERE patron_id = $1
    `, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("patron not found")
		}
		return nil, fmt.Errorf("failed to fetch patron: %v", err)
	} else {
		MembershipErr := tx.QueryRow(ctx, `
			SELECT membership_id, level
			FROM memberships
			WHERE patron_id = $1
		`, patron.PatronID).Scan(
			&membership.MembershipID,
			&membership.Level,
		)

		if MembershipErr != nil {
			return nil, fmt.Errorf("failed to fetch membership: %v", MembershipErr)
		}

		patron.Membership = &membership
		membership.PatronID = patron.PatronID

		PStatusErr := tx.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

		violationRows, violationErr := tx.Query(ctx, `
		SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
		FROM violation_records
		WHERE patron_id = $1
		`, patronID)

		if violationErr != nil {
			return nil, fmt.Errorf("failed to get violations: %v", violationErr)
		}

		defer violationRows.Close()

		for violationRows.Next() {
			var violation model.ViolationRecord
			err := violationRows.Scan(
				&violation.ViolationRecordID,
				&violation.ViolationType,
				&violation.ViolationInfo,
				&violation.ViolationCreated,
				&violation.ViolationStatus,
			)

			if err != nil {
				return nil, fmt.Errorf("failed scanning violation: %v", err)
			}
			violation.PatronID = patronID
			violations = append(violations, &violation)
		}

		patron.Violations = violations

	}

	_, DeleteErr := tx.Exec(ctx, `
		DELETE from patrons
		WHERE patron_id = $1
	`, patronID)

	if DeleteErr != nil {
		return nil, fmt.Errorf("deletion failed: %v", DeleteErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &patron, nil
}

// UpdateMembershipByPatronID is the resolver for the updateMembershipByPatronId field.
func (r *mutationResolver) UpdateMembershipByPatronID(ctx context.Context, patronID string, level model.MembershipLevel) (*model.Membership, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
        SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
    `, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	var membership model.Membership
	membership.PatronID = patronID

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	MembershipUpErr := tx.QueryRow(ctx, `
		UPDATE memberships
		SET level = $1
		WHERE patron_id = $2
		RETURNING membership_id, level
	`, level, patronID).Scan(
		&membership.MembershipID,
		&membership.Level,
	)

	if MembershipUpErr != nil {
		return nil, fmt.Errorf("failed to update memebership: %v", MembershipUpErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &membership, nil
}

// UpdateMembershipByMembershipID is the resolver for the updateMembershipByMembershipId field.
func (r *mutationResolver) UpdateMembershipByMembershipID(ctx context.Context, membershipID string, level model.MembershipLevel) (*model.Membership, error) {
	var membership model.Membership

	var exists bool
	err := r.DB.QueryRow(ctx, `
        SELECT EXISTS(SELECT 1 FROM memberships WHERE membership_id = $1)
    `, membershipID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking membership existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("membership id does not exist")
	}

	membership.MembershipID = membershipID

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	MembershipUpErr := tx.QueryRow(ctx, `
		UPDATE memberships
		SET level = $1
		WHERE membership_id = $2
		RETURNING patron_id, level
	`, level, membershipID).Scan(
		&membership.PatronID,
		&membership.Level,
	)

	if MembershipUpErr != nil {
		return nil, fmt.Errorf("failed to update memebership: %v", MembershipUpErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &membership, nil
}

// UpdatePatronStatus is the resolver for the updatePatronStatus field.
func (r *mutationResolver) UpdatePatronStatus(ctx context.Context, patronID string, warningCount *int32, unpaidFees *float64, patronStatus *model.Status) (*model.PatronStatus, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
	    SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
	`, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	var patron_status model.PatronStatus
	patron_status.PatronID = patronID

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	if warningCount != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET warning_count = $1
			WHERE patron_id = $2
		`, warningCount, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("updating warning count failed: %v", StatusUpErr)
		}
	}

	if patronStatus != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET patron_status = $1
			WHERE patron_id = $2
		`, patronStatus, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("updating patron_status failed: %v", StatusUpErr)
		}
	}

	if unpaidFees != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET unpaid_fees = $1
			WHERE patron_id = $2
		`, unpaidFees, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("inserting warning count failed: %v", StatusUpErr)
		}
	}

	FinalErr := tx.QueryRow(ctx, `
		SELECT warning_count, patron_status, unpaid_fees
		FROM patron_status
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	if FinalErr != nil {
		return nil, fmt.Errorf("fetching updated patron status failed: %v", FinalErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &patron_status, nil
}

// AddViolation is the resolver for the addViolation field.
func (r *mutationResolver) AddViolation(ctx context.Context, patronID string, violationType model.ViolationType, violationInfo string) (*model.ViolationRecord, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
	    SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
	`, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	// I am not going to change the database cause I can't be bothered which is why this exists
	dbViolationType := strings.ReplaceAll(string(violationType), "_", " ")

	var violation model.ViolationRecord
	violation.PatronID = patronID

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	_, ViolationInErr := tx.Exec(ctx, `
		INSERT INTO violation_records(patron_id, violation_type, violation_info)
		VALUES($1,$2,$3)
	`, patronID, dbViolationType, violationInfo)

	if ViolationInErr != nil {
		return nil, fmt.Errorf("inserting violation failed: %v", ViolationInErr)
	} else {
		violation.ViolationInfo = violationInfo
		violation.ViolationType = violationType
		violation.PatronID = patronID

		err := tx.QueryRow(ctx, `
	    	SELECT violation_record_id, violation_created::text, violation_status 
			FROM violation_records 
			WHERE patron_id = $1
		`, patronID).Scan(
			&violation.ViolationRecordID,
			&violation.ViolationCreated,
			&violation.ViolationStatus,
		)

		if err != nil {
			return nil, fmt.Errorf("fetching violation_record_id failed: %v", err)
		}

	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	violationCopy := violation

	r.SubscribersMutex.Lock()
	for subscriber := range r.ViolationSubscribers {
		select {
		case subscriber <- &violationCopy:
			// No action needed
		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", violation.ViolationRecordID)
		}
	}
	r.SubscribersMutex.Unlock()

	return &violation, nil
}

// UpdateViolationStatus is the resolver for the updateViolationStatus field.
func (r *mutationResolver) UpdateViolationStatus(ctx context.Context, violationID string, violationStatus model.ViolationStatus) (*model.ViolationRecord, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
	    SELECT EXISTS(SELECT 1 FROM violation_records WHERE violation_record_id = $1)
	`, violationID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking violation existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("violation does not exist")
	}

	var violation model.ViolationRecord
	violation.ViolationRecordID = violationID
	violation.ViolationStatus = violationStatus

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	vioErr := tx.QueryRow(ctx, `
		UPDATE violation_records
		SET violation_status = $1
		WHERE violation_record_id = $2
		RETURNING patron_id, violation_type, violation_info, violation_created::text
	`, violationStatus, violationID).Scan(
		&violation.PatronID,
		&violation.ViolationType,
		&violation.ViolationInfo,
		&violation.ViolationCreated,
	)

	if vioErr != nil {
		return nil, fmt.Errorf("updating violation status failed %v", vioErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	violationCopy := violation

	r.SubscribersMutex.Lock()
	for subscriber := range r.ViolationSubscribers {
		select {
		case subscriber <- &violationCopy:
			// No action needed
		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", violation.ViolationRecordID)
		}
	}
	r.SubscribersMutex.Unlock()

	return &violation, nil
}

// GetPatronByID is the resolver for the getPatronById field.
func (r *queryResolver) GetPatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron
	var membership model.Membership
	var patron_status model.PatronStatus
	var violations []*model.ViolationRecord

	err := r.DB.QueryRow(ctx, `
		SELECT first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		return nil, fmt.Errorf("patron does not exist: %v", err)
	} else {
		patron.PatronID = patronID
	}

	MembershipErr := r.DB.QueryRow(ctx, `
	SELECT membership_id, level
	FROM memberships
	WHERE patron_id = $1
	`, patron.PatronID).Scan(
		&membership.MembershipID,
		&membership.Level,
	)

	if MembershipErr != nil {
		return nil, fmt.Errorf("failed to fetch membership: %v", MembershipErr)
	}

	patron.Membership = &membership
	membership.PatronID = patron.PatronID

	PStatusErr := r.DB.QueryRow(ctx, `
		SELECT warning_count, patron_status, unpaid_fees
		FROM patron_status
		WHERE patron_id = $1 
	`, patron.PatronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	violationRows, violationErr := r.DB.Query(ctx, `
		SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
		FROM violation_records
		WHERE patron_id = $1
	`, patronID)

	if violationErr != nil {
		return nil, fmt.Errorf("failed to get violations: %v", violationErr)
	}

	defer violationRows.Close()

	for violationRows.Next() {
		var violation model.ViolationRecord
		err := violationRows.Scan(
			&violation.ViolationRecordID,
			&violation.ViolationType,
			&violation.ViolationInfo,
			&violation.ViolationCreated,
			&violation.ViolationStatus,
		)

		if err != nil {
			return nil, fmt.Errorf("failed scanning violation: %v", err)
		}
		violation.PatronID = patronID
		violations = append(violations, &violation)
	}

	patron.Violations = violations

	if PStatusErr != nil {
		return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
	}

	patron.Status = &patron_status
	patron_status.PatronID = patron.PatronID

	return &patron, nil
}

// GetAllPatrons is the resolver for the getAllPatrons field.
func (r *queryResolver) GetAllPatrons(ctx context.Context) ([]*model.Patron, error) {
	var patrons []*model.Patron

	rows, err := r.DB.Query(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
	`)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch patrons: %v", err)
	}

	defer rows.Close()

	for rows.Next() {
		var patron model.Patron
		var membership model.Membership
		var patron_status model.PatronStatus
		var violations []*model.ViolationRecord

		err := rows.Scan(
			&patron.PatronID,
			&patron.FirstName,
			&patron.LastName,
			&patron.PhoneNumber,
			&patron.PatronCreated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan patron: %v", err)
		}

		MembershipErr := r.DB.QueryRow(ctx, `
		SELECT membership_id, level
		FROM memberships
		WHERE patron_id = $1
		`, patron.PatronID).Scan(
			&membership.MembershipID,
			&membership.Level,
		)

		if MembershipErr != nil {
			return nil, fmt.Errorf("failed to fetch membership: %v", MembershipErr)
		}

		patron.Membership = &membership
		membership.PatronID = patron.PatronID

		PStatusErr := r.DB.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

		violationRows, violationErr := r.DB.Query(ctx, `
		SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
		FROM violation_records
		WHERE patron_id = $1
		`, patron.PatronID)

		if violationErr != nil {
			return nil, fmt.Errorf("failed to get violations: %v", violationErr)
		}

		defer violationRows.Close()

		for violationRows.Next() {
			var violation model.ViolationRecord
			err := violationRows.Scan(
				&violation.ViolationRecordID,
				&violation.ViolationType,
				&violation.ViolationInfo,
				&violation.ViolationCreated,
				&violation.ViolationStatus,
			)

			if err != nil {
				return nil, fmt.Errorf("failed scanning violation: %v", err)
			}
			violation.PatronID = patron.PatronID
			violations = append(violations, &violation)
		}

		patron.Violations = violations

		patrons = append(patrons, &patron)

	}

	return patrons, nil
}

// GetMembershipByLevel is the resolver for the getMembershipByLevel field.
func (r *queryResolver) GetMembershipByLevel(ctx context.Context, level model.MembershipLevel) ([]*model.Membership, error) {
	var memberships []*model.Membership

	membershipRows, membershipErr := r.DB.Query(ctx, `
		SELECT membership_id, patron_id
		FROM memberships
		WHERE level = $1
	`, level)

	if membershipErr != nil {
		return nil, fmt.Errorf("failed to get memberships: %v", membershipErr)
	}

	defer membershipRows.Close()

	for membershipRows.Next() {
		var membership model.Membership
		err := membershipRows.Scan(
			&membership.MembershipID,
			&membership.PatronID,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to scan membership: %v", err)
		}

		membership.Level = level

		memberships = append(memberships, &membership)
	}

	return memberships, nil
}

// GetMembershipByPatronID is the resolver for the getMembershipByPatronId field.
func (r *queryResolver) GetMembershipByPatronID(ctx context.Context, patronID string) (*model.Membership, error) {
	var membership model.Membership

	err := r.DB.QueryRow(ctx, `
		SELECT membership_id, level
		FROM memberships
		WHERE patron_id = $1
	`, patronID).Scan(
		&membership.MembershipID,
		&membership.Level,
	)

	if err != nil {
		return nil, fmt.Errorf("patron does not exist or failed getting membership: %v", err)
	}

	membership.PatronID = patronID

	return &membership, nil
}

// GetViolationByPatronID is the resolver for the getViolationByPatronId field.
func (r *queryResolver) GetViolationByPatronID(ctx context.Context, patronID string) ([]*model.ViolationRecord, error) {
	var violations []*model.ViolationRecord

	violationRows, violationErr := r.DB.Query(ctx, `
	SELECT violation_record_id, violation_type, violation_info, violation_created::text, violation_status
	FROM violation_records
	WHERE patron_id = $1
	`, patronID)

	if violationErr != nil {
		return nil, fmt.Errorf("failed to get violations: %v", violationErr)
	}

	defer violationRows.Close()

	for violationRows.Next() {
		var violation model.ViolationRecord
		err := violationRows.Scan(
			&violation.ViolationRecordID,
			&violation.ViolationType,
			&violation.ViolationInfo,
			&violation.ViolationCreated,
			&violation.ViolationStatus,
		)

		if err != nil {
			return nil, fmt.Errorf("failed scanning violation: %v", err)
		}
		violation.PatronID = patronID
		violations = append(violations, &violation)
	}

	return violations, nil
}

// GetViolationByType is the resolver for the getViolationByType field.
func (r *queryResolver) GetViolationByType(ctx context.Context, violationType model.ViolationType) ([]*model.ViolationRecord, error) {
	var violations []*model.ViolationRecord
	dbViolationType := strings.ReplaceAll(string(violationType), "_", " ")

	violationRows, violationErr := r.DB.Query(ctx, `
	SELECT violation_record_id, patron_id, violation_info, violation_created::text, violation_status
	FROM violation_records
	WHERE violation_type = $1
	`, dbViolationType)

	if violationErr != nil {
		return nil, fmt.Errorf("failed to get violations: %v", violationErr)
	}

	defer violationRows.Close()

	for violationRows.Next() {
		var violation model.ViolationRecord
		err := violationRows.Scan(
			&violation.ViolationRecordID,
			&violation.PatronID,
			&violation.ViolationInfo,
			&violation.ViolationCreated,
			&violation.ViolationStatus,
		)

		if err != nil {
			return nil, fmt.Errorf("failed scanning violation: %v", err)
		}
		violation.ViolationType = violationType
		violations = append(violations, &violation)
	}

	return violations, nil
}

// GetPatronStatusByType is the resolver for the getPatronStatusByType field.
func (r *queryResolver) GetPatronStatusByType(ctx context.Context, patronStatus model.Status) ([]*model.PatronStatus, error) {
	var patron_statuses []*model.PatronStatus

	statusRows, statusErr := r.DB.Query(ctx, `
		SELECT patron_id, warning_count, unpaid_fees
		FROM patron_status
		WHERE patron_status = $1
	`, patronStatus)

	if statusErr != nil {
		return nil, fmt.Errorf("failed to fetch patron_status_list: %v", statusErr)
	}

	defer statusRows.Close()

	for statusRows.Next() {
		var patron_status model.PatronStatus
		err := statusRows.Scan(
			&patron_status.PatronID,
			&patron_status.WarningCount,
			&patron_status.UnpaidFees,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to scan patron status: %v", err)
		}

		patron_status.PatronStatus = patronStatus
		patron_statuses = append(patron_statuses, &patron_status)
	}

	return patron_statuses, nil
}

// PatronCreated is the resolver for the patronCreated field.
func (r *subscriptionResolver) PatronCreated(ctx context.Context) (<-chan *model.Patron, error) {
	patronChan := make(chan *model.Patron, 1)

	r.SubscribersMutex.Lock()
	r.PatronSubscribers[patronChan] = true
	r.SubscribersMutex.Unlock()

	go func() {
		<-ctx.Done()
		r.SubscribersMutex.Lock()
		delete(r.PatronSubscribers, patronChan)
		close(patronChan)
		r.SubscribersMutex.Unlock()
	}()

	return patronChan, nil
}

// OngoingViolations is the resolver for the ongoingViolations field.
func (r *subscriptionResolver) OngoingViolations(ctx context.Context) (<-chan *model.ViolationRecord, error) {
	violationChan := make(chan *model.ViolationRecord, 1)

	r.SubscribersMutex.Lock()
	r.ViolationSubscribers[violationChan] = true
	r.SubscribersMutex.Unlock()

	go func() {
		<-ctx.Done()
		r.SubscribersMutex.Lock()
		delete(r.ViolationSubscribers, violationChan)
		close(violationChan)
		r.SubscribersMutex.Unlock()
	}()

	return violationChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) UpdateViolationStatusByPatronID(ctx context.Context, patronID string, violationStatus model.ViolationStatus) (*model.ViolationRecord, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
	    SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
	`, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	var violation model.ViolationRecord
	violation.PatronID = patronID
	violation.ViolationStatus = violationStatus

	vioErr := r.DB.QueryRow(ctx, `
		UPDATE violation_records
		SET violation_status = $1
		WHERE patron_id = $2
		RETURNING violation_record_id, violation_type, violation_info, violation_created::text
	`, violationStatus, patronID).Scan(
		&violation.ViolationRecordID,
		&violation.ViolationType,
		&violation.ViolationInfo,
		&violation.ViolationCreated,
	)

	if vioErr != nil {
		return nil, fmt.Errorf("updating violation status failed %v", vioErr)
	}

	return &violation, nil
}
*/

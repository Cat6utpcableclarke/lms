package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/RubyDEAD/lms/borrowing-service/graph/model"
	"github.com/RubyDEAD/lms/borrowing-service/services"
	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// BorrowBook implements the borrowBook mutation
// BorrowBook implements the borrowBook mutation
func (r *mutationResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	// Get book availability and connection
	available, conn, bookCopyIDStr, err := services.CheckAvailability(bookID)
	if err != nil {
		return nil, fmt.Errorf("failed to check book availability: %v", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// Validate availability
	if !available || bookCopyIDStr == "" {
		return nil, errors.New("no available book copies for borrowing")
	}

	// Convert string bookCopyID to int
	bookCopyID, err := strconv.Atoi(bookCopyIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid book copy ID format: %v", err)
	}

	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Create record
	now := time.Now()
	record := &model.BorrowRecord{
		ID:           uuid.New().String(),
		BookID:       bookID,
		PatronID:     patronID,
		BorrowedAt:   now.Format(time.RFC3339),
		DueDate:      now.AddDate(0, 0, 14).Format(time.RFC3339),
		RenewalCount: 0,
		Status:       model.BorrowStatusActive,
		BookCopyID:   int32(bookCopyID), // Now using the converted int value
	}

	// Insert into database
	const insertQuery = `
        INSERT INTO borrow_records 
        (id, book_id, patron_id, borrowed_at, due_date, renewal_count, status, book_copy_id)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

	_, err = tx.Exec(ctx, insertQuery,
		record.ID,
		record.BookID,
		record.PatronID,
		record.BorrowedAt,
		record.DueDate,
		record.RenewalCount,
		record.Status,
		record.BookCopyID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create borrow record: %v", err)
	}

	// Update book copy status in inventory service
	if err := services.SendUpdateRequest(conn, bookCopyIDStr, "Borrowed"); err != nil {
		return nil, fmt.Errorf("failed to update book copy status: %v", err)
	}

	// Commit transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return record, nil
}

// ReturnBook implements the returnBook mutation
func (r *mutationResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	// 1. Begin database transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// 2. Query the borrow record with book copy information
	var record model.BorrowRecord
	var borrowedAt, dueDate time.Time
	var returnedAt pgtype.Timestamptz
	var bookCopyID string

	const getQuery = `
	SELECT id, book_id, patron_id, borrowed_at, due_date, 
	       returned_at, renewal_count, status, book_copy_id
	FROM borrow_records
	WHERE id = $1 FOR UPDATE`

	err = tx.QueryRow(ctx, getQuery, recordID).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&borrowedAt,
		&dueDate,
		&returnedAt,
		&record.RenewalCount,
		&record.Status,
		&bookCopyID,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("borrow record not found or no borrowed book copy available")
		}
		return nil, fmt.Errorf("failed to get borrow record: %w", err)
	}

	// Convert timestamps to strings for the model
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)

	if returnedAt.Valid {
		returnedStr := returnedAt.Time.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	} else {
		record.ReturnedAt = nil
	}

	// 3. Check if already returned
	if record.Status == model.BorrowStatusReturned {
		return &record, nil
	}

	// 4. Get RabbitMQ connection for inventory update
	conn, err := services.GetRabbitMQConnection()
	if err != nil {
		return nil, fmt.Errorf("failed to get RabbitMQ connection: %w", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// 5. Update the borrow record
	now := time.Now()
	const updateQuery = `
		UPDATE borrow_records 
		SET returned_at = $1, status = $2 
		WHERE id = $3 
		RETURNING returned_at`

	var updatedReturnedAt time.Time
	err = tx.QueryRow(ctx, updateQuery, now, model.BorrowStatusReturned, recordID).Scan(&updatedReturnedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to update borrow record: %w", err)
	}

	updatedReturnedStr := updatedReturnedAt.Format(time.RFC3339)
	record.ReturnedAt = &updatedReturnedStr

	// 6. Commit transaction
	if err = tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// 7. Update book copy status in inventory service
	if err := services.SendUpdateRequest(conn, bookCopyID, "Available"); err != nil {
		log.Printf("Warning: Book return completed but inventory update failed. BookCopyID: %s, Error: %v",
			bookCopyID, err)
		// Consider adding retry logic or dead letter queue here
	}

	// 8. Return the updated record
	record.Status = model.BorrowStatusReturned
	return &record, nil
}

// RenewLoan implements the renewLoan mutation
func (r *mutationResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Get current record
	var record model.BorrowRecord
	const getQuery = `
		SELECT id, book_id, patron_id, borrowed_at, due_date, returned_at, renewal_count, status 
		FROM borrow_records 
		WHERE id = $1
		FOR UPDATE
	`
	err = tx.QueryRow(ctx, getQuery, recordID).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&record.BorrowedAt,
		&record.DueDate,
		&record.ReturnedAt,
		&record.RenewalCount,
		&record.Status,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("borrow record not found")
		}
		return nil, fmt.Errorf("failed to get borrow record: %v", err)
	}

	// Validate
	if record.Status == model.BorrowStatusReturned {
		return &model.RenewalError{
			Code:    model.RenewalErrorCodeLoanAlreadyReturned,
			Message: "cannot renew already returned loan",
		}, nil
	}

	if record.RenewalCount >= 2 {
		return &model.RenewalError{
			Code:    model.RenewalErrorCodeMaxRenewalsReached,
			Message: "maximum renewals reached",
		}, nil
	}

	// Check for reservations in Supabase
	var resCount int
	err = r.Supabase.DB.From("reservations").
		Select("count").
		Eq("book_id", record.BookID).
		Eq("status", string(model.ReservationStatusPending)).
		Execute(&resCount)
	if err == nil && resCount > 0 {
		return &model.RenewalError{
			Code:    model.RenewalErrorCodeItemReserved,
			Message: "book is reserved by another patron",
		}, nil
	}

	// Update record
	newDueDate := time.Now().AddDate(0, 0, 14).Format(time.RFC3339)
	previousDueDate := record.DueDate
	const updateQuery = `
		UPDATE borrow_records 
		SET previous_due_date = $1, due_date = $2, renewal_count = $3, status = $4
		WHERE id = $5
		RETURNING id, book_id, patron_id, borrowed_at, due_date, returned_at, renewal_count, status
	`
	err = tx.QueryRow(ctx, updateQuery,
		previousDueDate,
		newDueDate,
		record.RenewalCount+1,
		model.BorrowStatusRenewed,
		recordID,
	).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&record.BorrowedAt,
		&record.DueDate,
		&record.ReturnedAt,
		&record.RenewalCount,
		&record.Status,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update borrow record: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return &record, nil
}

// ReserveBook implements the reserveBook mutation
func (r *mutationResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	// Check book availability in Supabase
	var book struct {
		Available bool `json:"available"`
	}
	err := r.Supabase.DB.From("books").Select("available").Eq("id", bookID).Execute(&book)
	if err != nil {
		return nil, fmt.Errorf("failed to check book availability: %v", err)
	}
	if book.Available {
		return nil, errors.New("book is currently available, cannot reserve")
	}

	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Create reservation
	now := time.Now()
	reservation := &model.Reservation{
		ID:         uuid.New().String(),
		BookID:     bookID,
		PatronID:   patronID,
		ReservedAt: now.Format(time.RFC3339),
		ExpiresAt:  now.AddDate(0, 0, 3).Format(time.RFC3339),
		Status:     model.ReservationStatusPending,
	}

	// Insert into PostgreSQL
	const insertQuery = `
		INSERT INTO reservations 
		(id, book_id, patron_id, reserved_at, expires_at, status)
		VALUES ($1, $2, $3, $4, $5, $6)
	`
	_, err = tx.Exec(ctx, insertQuery,
		reservation.ID,
		reservation.BookID,
		reservation.PatronID,
		reservation.ReservedAt,
		reservation.ExpiresAt,
		reservation.Status,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return reservation, nil
}

// CancelReservation implements the cancelReservation mutation
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Get the reservation
	var reservation model.Reservation
	const getQuery = `
		SELECT id, book_id, patron_id, reserved_at, expires_at, status 
		FROM reservations 
		WHERE id = $1
		FOR UPDATE
	`
	err = tx.QueryRow(ctx, getQuery, id).Scan(
		&reservation.ID,
		&reservation.BookID,
		&reservation.PatronID,
		&reservation.ReservedAt,
		&reservation.ExpiresAt,
		&reservation.Status,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return false, errors.New("reservation not found")
		}
		return false, fmt.Errorf("failed to get reservation: %v", err)
	}

	if reservation.Status != model.ReservationStatusPending {
		return false, errors.New("only pending reservations can be cancelled")
	}

	// Update reservation
	const updateQuery = `
		UPDATE reservations 
		SET status = $1
		WHERE id = $2
	`
	_, err = tx.Exec(ctx, updateQuery, model.ReservationStatusCancelled, id)
	if err != nil {
		return false, fmt.Errorf("failed to cancel reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return true, nil
}

// FulfillReservation implements the fulfillReservation mutation
func (r *mutationResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Get the reservation
	var reservation model.Reservation
	const getQuery = `
		SELECT id, book_id, patron_id, reserved_at, expires_at, status 
		FROM reservations 
		WHERE id = $1
		FOR UPDATE
	`
	err = tx.QueryRow(ctx, getQuery, id).Scan(
		&reservation.ID,
		&reservation.BookID,
		&reservation.PatronID,
		&reservation.ReservedAt,
		&reservation.ExpiresAt,
		&reservation.Status,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("reservation not found")
		}
		return nil, fmt.Errorf("failed to get reservation: %v", err)
	}

	if reservation.Status != model.ReservationStatusPending {
		return nil, errors.New("only pending reservations can be fulfilled")
	}

	// Check expiration
	expiresAt, err := time.Parse(time.RFC3339, reservation.ExpiresAt)
	if err != nil {
		return nil, fmt.Errorf("invalid expiration date: %v", err)
	}
	if time.Now().After(expiresAt) {
		// Update reservation status to expired
		_, err = tx.Exec(ctx, `
			UPDATE reservations 
			SET status = $1
			WHERE id = $2
		`, model.ReservationStatusExpired, id)
		if err != nil {
			return nil, fmt.Errorf("failed to mark reservation as expired: %v", err)
		}
		return nil, errors.New("reservation has expired")
	}

	// Create borrow record
	_, err = r.BorrowBook(ctx, reservation.BookID, reservation.PatronID)
	if err != nil {
		return nil, fmt.Errorf("failed to create borrow record: %v", err)
	}

	// Update reservation status
	const updateQuery = `
		UPDATE reservations 
		SET status = $1
		WHERE id = $2
		RETURNING id, book_id, patron_id, reserved_at, expires_at, status
	`
	err = tx.QueryRow(ctx, updateQuery, model.ReservationStatusFulfilled, id).Scan(
		&reservation.ID,
		&reservation.BookID,
		&reservation.PatronID,
		&reservation.ReservedAt,
		&reservation.ExpiresAt,
		&reservation.Status,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return &reservation, nil
}

// BorrowRecords is the resolver for the borrowRecords field.
// BorrowRecords is the resolver for the borrowRecords field.
func (r *queryResolver) BorrowRecords(ctx context.Context, patronID *string, bookID *string, status *model.BorrowStatus) ([]*model.BorrowRecord, error) {
	query := `SELECT id, book_id, patron_id, borrowed_at, due_date, returned_at, renewal_count, status FROM borrow_records WHERE 1=1`
	args := []interface{}{}
	paramIndex := 1

	if patronID != nil {
		query += fmt.Sprintf(" AND patron_id = $%d", paramIndex)
		args = append(args, *patronID)
		paramIndex++
	}
	if bookID != nil {
		query += fmt.Sprintf(" AND book_id = $%d", paramIndex)
		args = append(args, *bookID)
		paramIndex++
	}
	if status != nil {
		query += fmt.Sprintf(" AND status = $%d", paramIndex)
		args = append(args, string(*status))
		paramIndex++
	}

	rows, err := r.DB.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query borrow records: %v", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			id, bookID, patronID, status string
			borrowedAt, dueDate          time.Time
			returnedAt                   *time.Time
			renewalCount                 int
		)

		err := rows.Scan(
			&id,
			&bookID,
			&patronID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&renewalCount,
			&status,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan borrow record: %v", err)
		}

		// Convert time values to RFC3339 strings
		record := &model.BorrowRecord{
			ID:           id,
			BookID:       bookID,
			PatronID:     patronID,
			BorrowedAt:   borrowedAt.Format(time.RFC3339),
			DueDate:      dueDate.Format(time.RFC3339),
			RenewalCount: int32(renewalCount),
			Status:       model.BorrowStatus(status),
		}

		// Handle nullable returned_at
		if returnedAt != nil {
			returnedAtStr := returnedAt.Format(time.RFC3339)
			record.ReturnedAt = &returnedAtStr
		}

		records = append(records, record)
	}

	return records, nil
}

// Reservations is the resolver for the reservations field.
func (r *queryResolver) Reservations(ctx context.Context, patronID *string, bookID *string, status *model.ReservationStatus) ([]*model.Reservation, error) {
	query := `SELECT id, book_id, patron_id, reserved_at, expires_at, status FROM reservations WHERE 1=1`
	args := []interface{}{}

	if patronID != nil {
		query += " AND patron_id = $1"
		args = append(args, *patronID)
	}
	if bookID != nil {
		if len(args) == 0 {
			query += " AND book_id = $1"
		} else {
			query += " AND book_id = $2"
		}
		args = append(args, *bookID)
	}
	if status != nil {
		pos := len(args) + 1
		query += fmt.Sprintf(" AND status = $%d", pos)
		args = append(args, string(*status))
	}

	rows, err := r.DB.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query reservations: %v", err)
	}
	defer rows.Close()

	var reservations []*model.Reservation
	for rows.Next() {
		var res model.Reservation
		err := rows.Scan(
			&res.ID,
			&res.BookID,
			&res.PatronID,
			&res.ReservedAt,
			&res.ExpiresAt,
			&res.Status,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan reservation: %v", err)
		}
		reservations = append(reservations, &res)
	}

	return reservations, nil
}

// OverdueRecords is the resolver for the overdueRecords field.
func (r *queryResolver) OverdueRecords(ctx context.Context) ([]*model.BorrowRecord, error) {
	now := time.Now()
	query := `
        SELECT id, book_id, patron_id, borrowed_at, due_date, returned_at, renewal_count, status 
        FROM borrow_records 
        WHERE status = $1 AND due_date < $2
    `

	rows, err := r.DB.Query(ctx, query, string(model.BorrowStatusActive), now)
	if err != nil {
		return nil, fmt.Errorf("failed to query overdue records: %v", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			id, bookID, patronID, status string
			borrowedAt, dueDate          time.Time
			returnedAt                   *time.Time
			renewalCount                 int
		)

		err := rows.Scan(
			&id,
			&bookID,
			&patronID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&renewalCount,
			&status,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan borrow record: %v", err)
		}

		record := &model.BorrowRecord{
			ID:           id,
			BookID:       bookID,
			PatronID:     patronID,
			BorrowedAt:   borrowedAt.Format(time.RFC3339),
			DueDate:      dueDate.Format(time.RFC3339),
			RenewalCount: int32(renewalCount),
			Status:       model.BorrowStatus(status),
		}

		if returnedAt != nil {
			returnedAtStr := returnedAt.Format(time.RFC3339)
			record.ReturnedAt = &returnedAtStr
		}

		records = append(records, record)
	}

	return records, nil
}

// PatronBorrowHistory is the resolver for the patronBorrowHistory field.
func (r *queryResolver) PatronBorrowHistory(ctx context.Context, patronID string) ([]*model.BorrowRecord, error) {
	query := `
        SELECT id, book_id, patron_id, borrowed_at, due_date, returned_at, renewal_count, status 
        FROM borrow_records 
        WHERE patron_id = $1
        ORDER BY borrowed_at DESC
    `

	rows, err := r.DB.Query(ctx, query, patronID)
	if err != nil {
		return nil, fmt.Errorf("failed to query patron borrow history: %v", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			id, bookID, patronID, status string
			borrowedAt, dueDate          time.Time
			returnedAt                   *time.Time
			renewalCount                 int
		)

		err := rows.Scan(
			&id,
			&bookID,
			&patronID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&renewalCount,
			&status,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan borrow record: %v", err)
		}

		record := &model.BorrowRecord{
			ID:           id,
			BookID:       bookID,
			PatronID:     patronID,
			BorrowedAt:   borrowedAt.Format(time.RFC3339),
			DueDate:      dueDate.Format(time.RFC3339),
			RenewalCount: int32(renewalCount),
			Status:       model.BorrowStatus(status),
		}

		if returnedAt != nil {
			returnedAtStr := returnedAt.Format(time.RFC3339)
			record.ReturnedAt = &returnedAtStr
		}

		records = append(records, record)
	}

	return records, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

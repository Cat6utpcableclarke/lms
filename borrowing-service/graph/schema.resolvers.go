package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/RubyDEAD/lms/borrowing-service/graph/model"
	"github.com/RubyDEAD/lms/borrowing-service/services"
	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// BorrowBook implements the borrowBook mutation
// BorrowBook implements the borrowBook mutation
func (r *mutationResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	activeBorrow, err := r.Resolver.Query().CheckActiveBorrow(ctx, bookID, patronID)
	if err != nil {
		return nil, fmt.Errorf("failed to check active borrow: %v", err)
	}
	if activeBorrow != nil {
		return nil, errors.New("you already have an active borrow for this book")
	}

	// Get book availability and connection
	available, conn, bookCopyIDStr, err := services.CheckAvailability(bookID)
	if err != nil {
		return nil, fmt.Errorf("failed to check book availability: %v", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// Validate availability
	if !available || bookCopyIDStr == "" {
		return nil, errors.New("no available book copies for borrowing")
	}

	// Convert string bookCopyID to int
	bookCopyID, err := strconv.Atoi(bookCopyIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid book copy ID format: %v", err)
	}

	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Create record
	now := time.Now()
	record := &model.BorrowRecord{
		ID:           uuid.New().String(),
		BookID:       bookID,
		PatronID:     patronID,
		BorrowedAt:   now.Format(time.RFC3339),
		DueDate:      now.AddDate(0, 0, 14).Format(time.RFC3339),
		RenewalCount: 0,
		Status:       model.BorrowStatusActive,
		BookCopyID:   int32(bookCopyID), // Now using the converted int value
	}

	// Insert into database
	const insertQuery = `
        INSERT INTO borrow_records 
        (id, book_id, patron_id, borrowed_at, due_date, renewal_count, status, book_copy_id)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

	_, err = tx.Exec(ctx, insertQuery,
		record.ID,
		record.BookID,
		record.PatronID,
		record.BorrowedAt,
		record.DueDate,
		record.RenewalCount,
		record.Status,
		record.BookCopyID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create borrow record: %v", err)
	}

	// Update book copy status in inventory service
	if err := services.SendUpdateRequest(conn, bookCopyIDStr, "Borrowed"); err != nil {
		return nil, fmt.Errorf("failed to update book copy status: %v", err)
	}

	// Commit transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return record, nil
}

func (r *mutationResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	// 1. Begin transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		log.Printf("Failed to begin transaction: %v", err)
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// 2. Query borrow record
	var record model.BorrowRecord
	var bookCopyID string
	var borrowedAt, dueDate time.Time
	var returnedAt pgtype.Timestamptz

	err = tx.QueryRow(ctx, `
        SELECT id, book_id, patron_id, borrowed_at, due_date, 
               returned_at, renewal_count, status, book_copy_id
        FROM borrow_records
        WHERE id = $1 FOR UPDATE`, recordID).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&borrowedAt,
		&dueDate,
		&returnedAt,
		&record.RenewalCount,
		&record.Status,
		&bookCopyID,
	)
	if err != nil {
		log.Printf("Failed to get borrow record: %v", err)
		return nil, fmt.Errorf("failed to get borrow record: %w", err)
	}

	// Convert timestamps
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)
	if returnedAt.Valid {
		returnedStr := returnedAt.Time.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	}

	// 3. Check if already returned
	if record.Status == model.BorrowStatusReturned {
		log.Printf("Book already returned (recordID: %s)", recordID)
		return &record, nil
	}

	// 4. Check for pending reservations BEFORE committing
	nextReservation := &model.Reservation{}
	var reservedAt, expiresAt time.Time
	err = tx.QueryRow(ctx, `
        SELECT id, book_id, patron_id, book_copy_id, reserved_at, expires_at, status
        FROM reservations
        WHERE book_id = $1 AND status = $2
        ORDER BY reserved_at ASC
        LIMIT 1`,
		record.BookID, model.ReservationStatusPending,
	).Scan(
		&nextReservation.ID,
		&nextReservation.BookID,
		&nextReservation.PatronID,
		&nextReservation.BookCopyID,
		&reservedAt,
		&expiresAt,
		&nextReservation.Status,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("No pending reservations found for bookID: %s", record.BookID)
		} else {
			log.Printf("Failed to query reservations: %v", err)
		}
	}

	// 5. Update the borrow record
	now := time.Now()
	_, err = tx.Exec(ctx, `
        UPDATE borrow_records 
        SET returned_at = $1, status = $2 
        WHERE id = $3`,
		now, model.BorrowStatusReturned, recordID,
	)
	if err != nil {
		log.Printf("Failed to update borrow record: %v", err)
		return nil, fmt.Errorf("failed to update borrow record: %w", err)
	}

	// 6. Commit transaction
	if err = tx.Commit(ctx); err != nil {
		log.Printf("Failed to commit transaction: %v", err)
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// 7. Update inventory status
	conn, err := services.GetRabbitMQConnection()
	if err != nil {
		log.Printf("Failed to get RabbitMQ connection: %v", err)
	} else {
		defer conn.Close()
		if err := services.SendUpdateRequest(conn, bookCopyID, "Available"); err != nil {
			log.Printf("Failed to update inventory status: %v", err)
		} else {
			log.Printf("Inventory updated successfully for bookCopyID: %s", bookCopyID)
		}
	}

	// 8. Send notification if reservation exists
	if nextReservation != nil && nextReservation.PatronID != "" {
		nextReservation.ReservedAt = reservedAt.Format(time.RFC3339)
		nextReservation.ExpiresAt = expiresAt.Format(time.RFC3339)

		log.Printf("Found reservation for patronID: %s", nextReservation.PatronID)

		go func(res *model.Reservation) {
			r.mutex.Lock()
			defer r.mutex.Unlock()

			if chans, ok := r.reservedBookAvailableChannels[res.PatronID]; ok {
				for _, ch := range chans {
					select {
					case ch <- res:
						log.Printf("Successfully notified patronID: %s", res.PatronID)
					default:
						log.Printf("Failed to send notification to patronID: %s (channel full)", res.PatronID)
					}
				}
			} else {
				log.Printf("No active subscribers found for patronID: %s", res.PatronID)
			}
		}(nextReservation)
	} else {
		log.Printf("No valid reservation found to notify")
	}

	// 9. Update return timestamp in response
	returnedStr := now.Format(time.RFC3339)
	record.ReturnedAt = &returnedStr
	record.Status = model.BorrowStatusReturned

	log.Printf("Successfully processed return for recordID: %s", recordID)
	return &record, nil
}

// RenewLoan implements the renewLoan mutation
func (r *mutationResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Declare temporary variables for time fields
	var (
		borrowedAt      time.Time
		dueDate         time.Time
		returnedAt      *time.Time
		previousDueDate *time.Time
		record          model.BorrowRecord
	)

	// 2. Scan into temporary variables first
	err = tx.QueryRow(ctx, `
		SELECT id, book_id, patron_id, borrowed_at, due_date,
			   returned_at, renewal_count, status, book_copy_id, previous_due_date
		FROM borrow_records
		WHERE id = $1
		FOR UPDATE`, recordID).Scan(
		&record.ID, &record.BookID, &record.PatronID,
		&borrowedAt, &dueDate,
		&returnedAt,
		&record.RenewalCount, &record.Status, &record.BookCopyID,
		&previousDueDate,
	)

	// Handle record not found
	if errors.Is(err, pgx.ErrNoRows) {
		return model.RenewalError{
			Code:    model.RenewalErrorCodeLoanNotFound,
			Message: "The specified loan record does not exist",
		}, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch loan record: %v", err)
	}

	// 3. Populate record fields
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)
	if returnedAt != nil {
		returnedStr := returnedAt.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	}
	if previousDueDate != nil {
		prevDueStr := previousDueDate.Format(time.RFC3339)
		record.PreviousDueDate = &prevDueStr
	}

	// 4. Validate renewal eligibility
	switch {
	case record.Status == model.BorrowStatusReturned:
		return model.RenewalError{
			Code:    model.RenewalErrorCodeLoanAlreadyReturned,
			Message: "Cannot renew - item has already been returned",
		}, nil

	case record.Status == model.BorrowStatusOverdue:
		return model.RenewalError{
			Code:    model.RenewalErrorCodePatronBlocked,
			Message: "Cannot renew - overdue items must be returned first",
		}, nil

	case record.RenewalCount >= 2:
		return model.RenewalError{
			Code:    model.RenewalErrorCodeMaxRenewalsReached,
			Message: "Maximum 2 renewals already used",
		}, nil
	}

	// 5. Check for active reservations
	var resCount int
	err = tx.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM reservations
		WHERE book_id = $1 AND status = $2`, record.BookID, model.ReservationStatusPending).Scan(&resCount)
	if err != nil {
		return nil, fmt.Errorf("failed to check reservations: %v", err)
	}
	if resCount > 0 {
		return model.RenewalError{
			Code:    model.RenewalErrorCodeItemReserved,
			Message: "Cannot renew - item has pending reservations",
		}, nil
	}

	// 6. Perform renewal (14-day hardcoded renewal period)
	newDueDate := time.Now().AddDate(0, 0, 14)
	_, err = tx.Exec(ctx, `
		UPDATE borrow_records
		SET previous_due_date = due_date,
			due_date = $1,
			renewal_count = renewal_count + 1,
			status = $2
		WHERE id = $3`,
		newDueDate, model.BorrowStatusRenewed, recordID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update loan record: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// 7. Update the record for response
	record.DueDate = newDueDate.Format(time.RFC3339)
	record.PreviousDueDate = &record.DueDate // Set previous due date
	record.RenewalCount++
	record.Status = model.BorrowStatusRenewed

	return record, nil
}

// ReserveBook implements the reserveBook mutation
func (r *mutationResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	// Check for an active reservation
	activeReserve, err := r.Resolver.Query().CheckActiveReserve(ctx, bookID, patronID)
	if err != nil {
		return nil, fmt.Errorf("failed to check active reservations: %v", err)
	}
	if activeReserve != nil {
		return nil, errors.New("you already have a pending reservation")
	}

	// Check for an active borrow
	activeBorrow, err := r.Resolver.Query().CheckActiveBorrow(ctx, bookID, patronID)
	if err != nil {
		return nil, fmt.Errorf("failed to check active borrow: %v", err)
	}
	if activeBorrow != nil {
		return nil, errors.New("you already have an active borrow for this book")
	}

	// Start a transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Get the earliest returning copy for reservation
	var targetCopyID int32
	var dueDate time.Time
	err = tx.QueryRow(ctx, `
        SELECT book_copy_id, due_date
        FROM borrow_records
        WHERE book_id = $1
        AND status = 'ACTIVE'
        ORDER BY due_date ASC
        LIMIT 1`,
		bookID,
	).Scan(&targetCopyID, &dueDate)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("no active borrows found - book should be available")
		}
		return nil, fmt.Errorf("failed to find reservable copy: %v", err)
	}

	// Create the reservation
	now := time.Now()
	reservation := &model.Reservation{
		ID:         uuid.New().String(),
		BookID:     bookID,
		PatronID:   patronID,
		BookCopyID: targetCopyID,
		ReservedAt: now.Format(time.RFC3339),
		ExpiresAt:  now.AddDate(0, 0, 3).Format(time.RFC3339),
		Status:     model.ReservationStatusPending,
	}

	_, err = tx.Exec(ctx, `
        INSERT INTO reservations 
        (id, book_id, patron_id, book_copy_id, reserved_at, expires_at, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		reservation.ID,
		reservation.BookID,
		reservation.PatronID,
		reservation.BookCopyID,
		reservation.ReservedAt,
		reservation.ExpiresAt,
		reservation.Status,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create reservation: %v", err)
	}

	// Commit the transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return reservation, nil
}

// CancelReservation implements the cancelReservation mutation
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Verify the reservation exists and is pending
	var status model.ReservationStatus
	err = tx.QueryRow(ctx, `
        SELECT status 
        FROM reservations 
        WHERE id = $1
        FOR UPDATE`, id).Scan(&status)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return false, errors.New("reservation not found")
		}
		return false, fmt.Errorf("failed to get reservation: %v", err)
	}

	if status != model.ReservationStatusPending {
		return false, errors.New("only pending reservations can be cancelled")
	}

	// 2. Update just the reservation status
	_, err = tx.Exec(ctx, `
        UPDATE reservations 
        SET status = $1
        WHERE id = $2`,
		model.ReservationStatusCancelled, id)
	if err != nil {
		return false, fmt.Errorf("failed to cancel reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return true, nil
}

// FulfillReservation is the resolver for the fulfillReservation field.
func (r *mutationResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Get and lock the reservation
	var reservation model.Reservation
	var reservedAt, expiresAt time.Time
	var status string

	err = tx.QueryRow(ctx, `
        SELECT id, book_id, patron_id, book_copy_id, reserved_at, expires_at, status 
        FROM reservations 
        WHERE id = $1
        FOR UPDATE`, id).Scan(
		&reservation.ID,
		&reservation.BookID,
		&reservation.PatronID,
		&reservation.BookCopyID,
		&reservedAt,
		&expiresAt,
		&status,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, &FulfillmentError{Code: "NOT_FOUND", Message: "reservation not found"}
		}
		return nil, fmt.Errorf("failed to get reservation: %v", err)
	}

	reservation.Status = model.ReservationStatus(status)
	reservation.ReservedAt = reservedAt.Format(time.RFC3339)
	reservation.ExpiresAt = expiresAt.Format(time.RFC3339)

	// 2. Validate status
	if model.ReservationStatus(status) != model.ReservationStatusPending {
		return nil, &FulfillmentError{
			Code:    "INVALID_STATUS",
			Message: fmt.Sprintf("cannot fulfill reservation with status: %s", status),
		}
	}

	// 3. Check expiration
	if time.Now().After(expiresAt) {
		if _, err = tx.Exec(ctx, `
            UPDATE reservations SET status = $1 WHERE id = $2`,
			model.ReservationStatusExpired, id,
		); err != nil {
			return nil, fmt.Errorf("failed to mark reservation as expired: %v", err)
		}
		return nil, &FulfillmentError{
			Code:    "EXPIRED",
			Message: "reservation has expired",
		}
	}

	// 4. Update reservation status
	var updatedReservedAt, updatedExpiresAt time.Time
	err = tx.QueryRow(ctx, `
        UPDATE reservations 
        SET status = $1
        WHERE id = $2
        RETURNING reserved_at, expires_at`,
		model.ReservationStatusFulfilled, id,
	).Scan(&updatedReservedAt, &updatedExpiresAt)
	if err != nil {
		return nil, fmt.Errorf("failed to update reservation: %v", err)
	}

	// 5. Get RabbitMQ connection for inventory update
	_, conn, _, err := services.CheckAvailability(reservation.BookID)
	if err != nil {
		return nil, fmt.Errorf("failed to get inventory connection: %v", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// 6. Update book copy status in inventory
	bookCopyIDStr := strconv.Itoa(int(reservation.BookCopyID))
	if err := services.SendUpdateRequest(conn, bookCopyIDStr, "Borrowed"); err != nil {
		return nil, fmt.Errorf("failed to update book copy status: %v", err)
	}

	// 7. Create borrow record
	now := time.Now()
	borrowRecordID := uuid.New().String()
	if _, err = tx.Exec(ctx, `
        INSERT INTO borrow_records (
            id, book_id, patron_id, book_copy_id, 
            borrowed_at, due_date, status, renewal_count
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
		borrowRecordID,
		reservation.BookID,
		reservation.PatronID,
		reservation.BookCopyID,
		now,
		now.AddDate(0, 0, 14),
		model.BorrowStatusActive,
		0,
	); err != nil {
		return nil, fmt.Errorf("failed to create borrow record: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// Prepare final response
	reservation.Status = model.ReservationStatusFulfilled
	reservation.ReservedAt = updatedReservedAt.Format(time.RFC3339)
	reservation.ExpiresAt = updatedExpiresAt.Format(time.RFC3339)

	return &reservation, nil
}

// BorrowRecords is the resolver for the borrowRecords field.
// BorrowRecords is the resolver for the borrowRecords field.
// BorrowRecords is the resolver for the borrowRecords field.
func (r *queryResolver) BorrowRecords(ctx context.Context, patronID *string, bookID *string, status *model.BorrowStatus) ([]*model.BorrowRecord, error) {
	// Build the query dynamically
	query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE 1=1`

	args := []interface{}{}
	argPos := 1

	if patronID != nil {
		query += fmt.Sprintf(" AND patron_id = $%d", argPos)
		args = append(args, *patronID)
		argPos++
	}
	if bookID != nil {
		query += fmt.Sprintf(" AND book_id = $%d", argPos)
		args = append(args, *bookID)
		argPos++
	}
	if status != nil {
		query += fmt.Sprintf(" AND status = $%d", argPos)
		args = append(args, string(*status))
		argPos++
	}

	query += " ORDER BY borrowed_at DESC"

	rows, err := r.DB.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query borrow records: %w", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			record                  model.BorrowRecord
			borrowedAt, dueDate     time.Time
			returnedAt, prevDueDate pgtype.Timestamptz
		)

		err := rows.Scan(
			&record.ID,
			&record.BookID,
			&record.PatronID,
			&record.BookCopyID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&record.RenewalCount,
			&record.Status,
			&prevDueDate,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan record: %w", err)
		}

		// Convert timestamps
		record.BorrowedAt = borrowedAt.Format(time.RFC3339)
		record.DueDate = dueDate.Format(time.RFC3339)

		if returnedAt.Valid {
			returnedStr := returnedAt.Time.Format(time.RFC3339)
			record.ReturnedAt = &returnedStr
		}
		if prevDueDate.Valid {
			prevDueStr := prevDueDate.Time.Format(time.RFC3339)
			record.PreviousDueDate = &prevDueStr
		}

		records = append(records, &record)
	}

	return records, nil
}

// Reservations is the resolver for the reservations field.
func (r *queryResolver) Reservations(ctx context.Context, patronID *string, bookID *string, status *model.ReservationStatus) ([]*model.Reservation, error) {
	query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            reserved_at, expires_at, status
        FROM reservations 
        WHERE 1=1`

	args := []interface{}{}
	argPos := 1

	if patronID != nil {
		query += fmt.Sprintf(" AND patron_id = $%d", argPos)
		args = append(args, *patronID)
		argPos++
	}
	if bookID != nil {
		query += fmt.Sprintf(" AND book_id = $%d", argPos)
		args = append(args, *bookID)
		argPos++
	}
	if status != nil {
		query += fmt.Sprintf(" AND status = $%d", argPos)
		args = append(args, string(*status))
		argPos++
	}

	query += " ORDER BY reserved_at DESC"

	rows, err := r.DB.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query reservations: %w", err)
	}
	defer rows.Close()

	var reservations []*model.Reservation
	for rows.Next() {
		var res model.Reservation
		var reservedAt, expiresAt time.Time

		err := rows.Scan(
			&res.ID,
			&res.BookID,
			&res.PatronID,
			&res.BookCopyID,
			&reservedAt,
			&expiresAt,
			&res.Status,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan reservation: %w", err)
		}

		res.ReservedAt = reservedAt.Format(time.RFC3339)
		res.ExpiresAt = expiresAt.Format(time.RFC3339)
		reservations = append(reservations, &res)
	}

	return reservations, nil
}

// OverdueRecords is the resolver for the overdueRecords field.
func (r *queryResolver) OverdueRecords(ctx context.Context) ([]*model.BorrowRecord, error) {
	query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE status = $1 
        AND due_date < NOW()
        ORDER BY due_date ASC`

	rows, err := r.DB.Query(ctx, query, string(model.BorrowStatusActive))
	if err != nil {
		return nil, fmt.Errorf("failed to query overdue records: %w", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			record                  model.BorrowRecord
			borrowedAt, dueDate     time.Time
			returnedAt, prevDueDate pgtype.Timestamptz
		)

		err := rows.Scan(
			&record.ID,
			&record.BookID,
			&record.PatronID,
			&record.BookCopyID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&record.RenewalCount,
			&record.Status,
			&prevDueDate,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan record: %w", err)
		}

		record.BorrowedAt = borrowedAt.Format(time.RFC3339)
		record.DueDate = dueDate.Format(time.RFC3339)

		if returnedAt.Valid {
			returnedStr := returnedAt.Time.Format(time.RFC3339)
			record.ReturnedAt = &returnedStr
		}
		if prevDueDate.Valid {
			prevDueStr := prevDueDate.Time.Format(time.RFC3339)
			record.PreviousDueDate = &prevDueStr
		}

		records = append(records, &record)
	}

	return records, nil
}

// PatronBorrowHistory is the resolver for the patronBorrowHistory field.
func (r *queryResolver) PatronBorrowHistory(ctx context.Context, patronID string) ([]*model.BorrowRecord, error) {
	query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE patron_id = $1
        ORDER BY borrowed_at DESC`

	rows, err := r.DB.Query(ctx, query, patronID)
	if err != nil {
		return nil, fmt.Errorf("failed to query patron history: %w", err)
	}
	defer rows.Close()

	var records []*model.BorrowRecord
	for rows.Next() {
		var (
			record                  model.BorrowRecord
			borrowedAt, dueDate     time.Time
			returnedAt, prevDueDate pgtype.Timestamptz
		)

		err := rows.Scan(
			&record.ID,
			&record.BookID,
			&record.PatronID,
			&record.BookCopyID,
			&borrowedAt,
			&dueDate,
			&returnedAt,
			&record.RenewalCount,
			&record.Status,
			&prevDueDate,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan record: %w", err)
		}

		record.BorrowedAt = borrowedAt.Format(time.RFC3339)
		record.DueDate = dueDate.Format(time.RFC3339)

		if returnedAt.Valid {
			returnedStr := returnedAt.Time.Format(time.RFC3339)
			record.ReturnedAt = &returnedStr
		}
		if prevDueDate.Valid {
			prevDueStr := prevDueDate.Time.Format(time.RFC3339)
			record.PreviousDueDate = &prevDueStr
		}

		records = append(records, &record)
	}

	return records, nil
}

// CheckActiveBorrow is the resolver for the checkActiveBorrow field.
func (r *queryResolver) CheckActiveBorrow(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	// 1. Begin transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// 2. Query for active borrow record
	var (
		record              model.BorrowRecord
		borrowedAt, dueDate time.Time
		returnedAt          pgtype.Timestamptz
	)

	err = tx.QueryRow(ctx, `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records
        WHERE book_id = $1 
        AND patron_id = $2
        AND status = $3
        LIMIT 1`,
		bookID, patronID, model.BorrowStatusActive,
	).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&record.BookCopyID,
		&borrowedAt,
		&dueDate,
		&returnedAt,
		&record.RenewalCount,
		&record.Status,
		&record.PreviousDueDate,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil // No active borrow found
		}
		return nil, fmt.Errorf("failed to query active borrow: %w", err)
	}

	// 3. Convert timestamps
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)

	if returnedAt.Valid {
		returnedStr := returnedAt.Time.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	}

	// 4. Check if the record is actually active (additional validation)
	if record.Status != model.BorrowStatusActive {
		return nil, nil
	}

	// 5. Commit transaction (read-only, but maintains consistency)
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &record, nil
}

// CheckActiveReserve is the resolver for the checkActiveReserve field.
func (r *queryResolver) CheckActiveReserve(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	// 1. Begin transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// 2. Query for active reservation
	var (
		reservation model.Reservation
		reservedAt  time.Time
		expiresAt   time.Time
	)

	err = tx.QueryRow(ctx, `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            reserved_at, expires_at, status
        FROM reservations
        WHERE book_id = $1 
        AND patron_id = $2
        AND status = $3
        AND expires_at > NOW()
        LIMIT 1`,
		bookID, patronID, model.ReservationStatusPending,
	).Scan(
		&reservation.ID,
		&reservation.BookID,
		&reservation.PatronID,
		&reservation.BookCopyID,
		&reservedAt,
		&expiresAt,
		&reservation.Status,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil // No active reservation found
		}
		return nil, fmt.Errorf("failed to query active reservation: %w", err)
	}

	// 3. Convert timestamps
	reservation.ReservedAt = reservedAt.Format(time.RFC3339)
	reservation.ExpiresAt = expiresAt.Format(time.RFC3339)

	// 4. Additional validation (though the query should have handled this)
	if reservation.Status != model.ReservationStatusPending {
		return nil, nil
	}

	// 5. Commit transaction (read-only)
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &reservation, nil
}

// ReservedBookAvailable is the resolver for the reservedBookAvailable field.
func (r *subscriptionResolver) ReservedBookAvailable(ctx context.Context, patronID string) (<-chan *model.Reservation, error) {
	updates := make(chan *model.Reservation, 1)

	// Register this subscriber
	r.mutex.Lock()
	r.reservedBookAvailableChannels[patronID] = append(r.reservedBookAvailableChannels[patronID], updates)
	r.mutex.Unlock()

	go func() {
		<-ctx.Done()

		// Remove subscriber on disconnect
		r.mutex.Lock()
		channels := r.reservedBookAvailableChannels[patronID]
		for i, ch := range channels {
			if ch == updates {
				r.reservedBookAvailableChannels[patronID] = append(channels[:i], channels[i+1:]...)
				break
			}
		}
		r.mutex.Unlock()

		close(updates)
	}()

	return updates, nil
}

// ReservationCreated implements SubscriptionResolver.
func (r *subscriptionResolver) ReservationCreated(ctx context.Context, bookID string) (<-chan *model.Reservation, error) {
	updates := make(chan *model.Reservation, 1)

	// Register subscriber safely
	r.mutex.Lock()
	r.reservationCreatedChannels[bookID] = append(r.reservationCreatedChannels[bookID], updates)
	r.mutex.Unlock()

	// Handle context cancellation and cleanup
	go func() {
		<-ctx.Done()

		// Remove the channel from subscribers
		r.mutex.Lock()
		channels := r.reservationCreatedChannels[bookID]
		for i, ch := range channels {
			if ch == updates {
				r.reservationCreatedChannels[bookID] = append(channels[:i], channels[i+1:]...)
				break
			}
		}
		// Optional: clean up the map entry if no more subscribers
		if len(r.reservationCreatedChannels[bookID]) == 0 {
			delete(r.reservationCreatedChannels, bookID)
		}
		r.mutex.Unlock()

		close(updates)
	}()

	return updates, nil
}

// BorrowRecordUpdated implements SubscriptionResolver.
func (r *subscriptionResolver) BorrowRecordUpdated(ctx context.Context, patronID string) (<-chan *model.BorrowRecord, error) {
	updates := make(chan *model.BorrowRecord)

	go func() {
		defer close(updates)

		// Simulate listening to updates for the given patronID
		// Replace this with actual implementation, e.g., listening to a message queue or database changes
		for {
			select {
			case <-ctx.Done():
				return
			case <-time.After(5 * time.Second): // Simulate an update every 5 seconds
				updates <- &model.BorrowRecord{
					ID:         "example-id",
					BookID:     "example-book-id",
					PatronID:   patronID,
					BorrowedAt: time.Now().Format(time.RFC3339),
					DueDate:    time.Now().AddDate(0, 0, 14).Format(time.RFC3339),
					Status:     model.BorrowStatusActive,
				}
			}
		}
	}()

	return updates, nil
}

// BroadcastReservationAvailable is the resolver for the broadcastReservationAvailable field.
func (r *subscriptionResolver) BroadcastReservationAvailable(ctx context.Context) (<-chan *model.Reservation, error) {
	updates := make(chan *model.Reservation, 1)

	// Register this subscriber
	r.mutex.Lock()
	r.reservedBookAvailableChannels["global"] = append(r.reservedBookAvailableChannels["global"], updates)
	r.mutex.Unlock()

	go func() {
		<-ctx.Done()

		r.mutex.Lock()
		defer r.mutex.Unlock()

		channels := r.reservedBookAvailableChannels["global"]
		for i, ch := range channels {
			if ch == updates {
				// Remove the channel from the slice
				channels = append(channels[:i], channels[i+1:]...)
				r.reservedBookAvailableChannels["global"] = channels

				// Close the channel after removing it to prevent races
				close(ch)
				break
			}
		}
	}()

	return updates, nil
}

// BroadcastReservationCreated is the resolver for the broadcastReservationCreated field.
func (r *subscriptionResolver) BroadcastReservationCreated(ctx context.Context) (<-chan *model.Reservation, error) {
	updates := make(chan *model.Reservation, 1)

	// Example logic to broadcast a reservation
	go func() {
		defer close(updates)
		// Simulate sending a reservation update
		select {
		case updates <- &model.Reservation{
			ID:         "example-id",
			BookID:     "example-book-id",
			PatronID:   "example-patron-id",
			ReservedAt: time.Now().Format(time.RFC3339),
			ExpiresAt:  time.Now().AddDate(0, 0, 3).Format(time.RFC3339),
			Status:     model.ReservationStatusPending,
		}:
		case <-ctx.Done():
			return
		}
	}()

	return updates, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/RubyDEAD/lms/borrowing-service/graph/model"
	"github.com/RubyDEAD/lms/borrowing-service/services"
	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// BorrowBook implements the borrowBook mutation
// BorrowBook implements the borrowBook mutation
func (r *mutationResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	// Get book availability and connection
	available, conn, bookCopyIDStr, err := services.CheckAvailability(bookID)
	if err != nil {
		return nil, fmt.Errorf("failed to check book availability: %v", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// Validate availability
	if !available || bookCopyIDStr == "" {
		return nil, errors.New("no available book copies for borrowing")
	}

	// Convert string bookCopyID to int
	bookCopyID, err := strconv.Atoi(bookCopyIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid book copy ID format: %v", err)
	}

	// Start transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// Create record
	now := time.Now()
	record := &model.BorrowRecord{
		ID:           uuid.New().String(),
		BookID:       bookID,
		PatronID:     patronID,
		BorrowedAt:   now.Format(time.RFC3339),
		DueDate:      now.AddDate(0, 0, 14).Format(time.RFC3339),
		RenewalCount: 0,
		Status:       model.BorrowStatusActive,
		BookCopyID:   int32(bookCopyID), // Now using the converted int value
	}

	// Insert into database
	const insertQuery = `
        INSERT INTO borrow_records 
        (id, book_id, patron_id, borrowed_at, due_date, renewal_count, status, book_copy_id)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

	_, err = tx.Exec(ctx, insertQuery,
		record.ID,
		record.BookID,
		record.PatronID,
		record.BorrowedAt,
		record.DueDate,
		record.RenewalCount,
		record.Status,
		record.BookCopyID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create borrow record: %v", err)
	}

	// Update book copy status in inventory service
	if err := services.SendUpdateRequest(conn, bookCopyIDStr, "Borrowed"); err != nil {
		return nil, fmt.Errorf("failed to update book copy status: %v", err)
	}

	// Commit transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return record, nil
}

// ReturnBook implements the returnBook mutation
func (r *mutationResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	// 1. Begin database transaction
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// 2. Query the borrow record with book copy information
	var record model.BorrowRecord
	var borrowedAt, dueDate time.Time
	var returnedAt pgtype.Timestamptz
	var bookCopyID string

	const getQuery = `
	SELECT id, book_id, patron_id, borrowed_at, due_date, 
	       returned_at, renewal_count, status, book_copy_id
	FROM borrow_records
	WHERE id = $1 FOR UPDATE`

	err = tx.QueryRow(ctx, getQuery, recordID).Scan(
		&record.ID,
		&record.BookID,
		&record.PatronID,
		&borrowedAt,
		&dueDate,
		&returnedAt,
		&record.RenewalCount,
		&record.Status,
		&bookCopyID,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, errors.New("borrow record not found or no borrowed book copy available")
		}
		return nil, fmt.Errorf("failed to get borrow record: %w", err)
	}

	// Convert timestamps to strings for the model
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)

	if returnedAt.Valid {
		returnedStr := returnedAt.Time.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	} else {
		record.ReturnedAt = nil
	}

	// 3. Check if already returned
	if record.Status == model.BorrowStatusReturned {
		return &record, nil
	}

	// 4. Get RabbitMQ connection for inventory update
	conn, err := services.GetRabbitMQConnection()
	if err != nil {
		return nil, fmt.Errorf("failed to get RabbitMQ connection: %w", err)
	}
	defer func() {
		if conn != nil && !conn.IsClosed() {
			conn.Close()
		}
	}()

	// 5. Update the borrow record
	now := time.Now()
	const updateQuery = `
		UPDATE borrow_records 
		SET returned_at = $1, status = $2 
		WHERE id = $3 
		RETURNING returned_at`

	var updatedReturnedAt time.Time
	err = tx.QueryRow(ctx, updateQuery, now, model.BorrowStatusReturned, recordID).Scan(&updatedReturnedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to update borrow record: %w", err)
	}

	updatedReturnedStr := updatedReturnedAt.Format(time.RFC3339)
	record.ReturnedAt = &updatedReturnedStr

	// 6. Commit transaction
	if err = tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// 7. Update book copy status in inventory service
	if err := services.SendUpdateRequest(conn, bookCopyID, "Available"); err != nil {
		log.Printf("Warning: Book return completed but inventory update failed. BookCopyID: %s, Error: %v",
			bookCopyID, err)
		// Consider adding retry logic or dead letter queue here
	}

	// 8. Return the updated record
	record.Status = model.BorrowStatusReturned
	return &record, nil
}

// RenewLoan implements the renewLoan mutation
func (r *mutationResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Declare temporary variables for time fields
	var (
		borrowedAt      time.Time
		dueDate         time.Time
		returnedAt      *time.Time
		previousDueDate *time.Time
		record          model.BorrowRecord
	)

	// 2. Scan into temporary variables first
	err = tx.QueryRow(ctx, `
		SELECT id, book_id, patron_id, borrowed_at, due_date,
			   returned_at, renewal_count, status, book_copy_id, previous_due_date
		FROM borrow_records
		WHERE id = $1
		FOR UPDATE`, recordID).Scan(
		&record.ID, &record.BookID, &record.PatronID,
		&borrowedAt, &dueDate,
		&returnedAt,
		&record.RenewalCount, &record.Status, &record.BookCopyID,
		&previousDueDate,
	)

	// Handle record not found
	if errors.Is(err, pgx.ErrNoRows) {
		return model.RenewalError{
			Code:    model.RenewalErrorCodeLoanNotFound,
			Message: "The specified loan record does not exist",
		}, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch loan record: %v", err)
	}

	// 3. Populate record fields
	record.BorrowedAt = borrowedAt.Format(time.RFC3339)
	record.DueDate = dueDate.Format(time.RFC3339)
	if returnedAt != nil {
		returnedStr := returnedAt.Format(time.RFC3339)
		record.ReturnedAt = &returnedStr
	}
	if previousDueDate != nil {
		prevDueStr := previousDueDate.Format(time.RFC3339)
		record.PreviousDueDate = &prevDueStr
	}

	// 4. Validate renewal eligibility
	switch {
	case record.Status == model.BorrowStatusReturned:
		return model.RenewalError{
			Code:    model.RenewalErrorCodeLoanAlreadyReturned,
			Message: "Cannot renew - item has already been returned",
		}, nil

	case record.Status == model.BorrowStatusOverdue:
		return model.RenewalError{
			Code:    model.RenewalErrorCodePatronBlocked,
			Message: "Cannot renew - overdue items must be returned first",
		}, nil

	case record.RenewalCount >= 2:
		return model.RenewalError{
			Code:    model.RenewalErrorCodeMaxRenewalsReached,
			Message: "Maximum 2 renewals already used",
		}, nil
	}

	// 5. Check for active reservations
	var resCount int
	err = tx.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM reservations
		WHERE book_id = $1 AND status = $2`, record.BookID, model.ReservationStatusPending).Scan(&resCount)
	if err != nil {
		return nil, fmt.Errorf("failed to check reservations: %v", err)
	}
	if resCount > 0 {
		return model.RenewalError{
			Code:    model.RenewalErrorCodeItemReserved,
			Message: "Cannot renew - item has pending reservations",
		}, nil
	}

	// 6. Perform renewal (14-day hardcoded renewal period)
	newDueDate := time.Now().AddDate(0, 0, 14)
	_, err = tx.Exec(ctx, `
		UPDATE borrow_records
		SET previous_due_date = due_date,
			due_date = $1,
			renewal_count = renewal_count + 1,
			status = $2
		WHERE id = $3`,
		newDueDate, model.BorrowStatusRenewed, recordID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update loan record: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// 7. Update the record for response
	record.DueDate = newDueDate.Format(time.RFC3339)
	record.PreviousDueDate = &record.DueDate // Set previous due date
	record.RenewalCount++
	record.Status = model.BorrowStatusRenewed

	return record, nil
}

// ReserveBook implements the reserveBook mutation
func (r *mutationResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Check for existing active reservation for this patron+book
	var existingReservationCount int
	err = tx.QueryRow(ctx, `
        SELECT COUNT(*) 
        FROM reservations 
        WHERE book_id = $1 
        AND patron_id = $2
        AND status = 'PENDING'
        AND expires_at > NOW()`,
		bookID, patronID,
	).Scan(&existingReservationCount)

	if err != nil {
		return nil, fmt.Errorf("failed to check existing reservations: %v", err)
	}
	if existingReservationCount > 0 {
		tx.Rollback(ctx)
		return nil, errors.New("you already have an active reservation for this book")
	}

	// 2. Check if book exists in the system
	var bookExists bool
	err = tx.QueryRow(ctx, `
        SELECT EXISTS(
            SELECT 1 FROM borrow_records WHERE book_id = $1
        )`, bookID).Scan(&bookExists)

	if err != nil {
		return nil, fmt.Errorf("database error: %v", err)
	}
	if !bookExists {
		return nil, errors.New("no copies of this book exist in the system or book hasnt been borrowed, use BorrowBook instead!")
	}

	// 3. Check for available copies (RETURNED status with recent return)
	var availableCopyID int32
	err = tx.QueryRow(ctx, `
        SELECT book_copy_id 
        FROM borrow_records 
        WHERE book_id = $1 
        AND status = 'RETURNED'
        AND returned_at >= NOW() - INTERVAL '5 minutes'
        LIMIT 1`,
		bookID,
	).Scan(&availableCopyID)

	if err == nil {
		tx.Rollback(ctx)
		return nil, fmt.Errorf("copy %d is available (recently returned) - please borrow instead", availableCopyID)
	} else if !errors.Is(err, pgx.ErrNoRows) {
		return nil, fmt.Errorf("database error: %v", err)
	}

	// 4. Check for active borrows
	var activeBorrowExists bool
	err = tx.QueryRow(ctx, `
        SELECT EXISTS(
            SELECT 1 FROM borrow_records 
            WHERE book_id = $1 
            AND status = 'ACTIVE'
            AND (returned_at IS NULL OR returned_at > NOW())
        )`, bookID).Scan(&activeBorrowExists)

	if err != nil {
		return nil, fmt.Errorf("database error: %v", err)
	}
	if !activeBorrowExists {
		tx.Rollback(ctx)
		return nil, errors.New("no active borrows found - book should be available")
	}

	// 5. Get the earliest returning copy for reservation
	var targetCopyID int32
	var dueDate time.Time
	err = tx.QueryRow(ctx, `
        SELECT book_copy_id, due_date
        FROM borrow_records
        WHERE book_id = $1
        AND status = 'ACTIVE'
        ORDER BY due_date ASC
        LIMIT 1`,
		bookID,
	).Scan(&targetCopyID, &dueDate)

	if err != nil {
		return nil, fmt.Errorf("failed to find reservable copy: %v", err)
	}

	// 6. Create reservation
	now := time.Now()
	reservation := &model.Reservation{
		ID:         uuid.New().String(),
		BookID:     bookID,
		PatronID:   patronID,
		BookCopyID: targetCopyID,
		ReservedAt: now.Format(time.RFC3339),
		ExpiresAt:  now.AddDate(0, 0, 3).Format(time.RFC3339),
		Status:     model.ReservationStatusPending,
	}

	_, err = tx.Exec(ctx, `
        INSERT INTO reservations 
        (id, book_id, patron_id, book_copy_id, reserved_at, expires_at, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		reservation.ID,
		reservation.BookID,
		reservation.PatronID,
		reservation.BookCopyID,
		reservation.ReservedAt,
		reservation.ExpiresAt,
		reservation.Status,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return reservation, nil
}

// CancelReservation implements the cancelReservation mutation
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback(ctx)

	// 1. Verify the reservation exists and is pending
	var status model.ReservationStatus
	err = tx.QueryRow(ctx, `
        SELECT status 
        FROM reservations 
        WHERE id = $1
        FOR UPDATE`, id).Scan(&status)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return false, errors.New("reservation not found")
		}
		return false, fmt.Errorf("failed to get reservation: %v", err)
	}

	if status != model.ReservationStatusPending {
		return false, errors.New("only pending reservations can be cancelled")
	}

	// 2. Update just the reservation status
	_, err = tx.Exec(ctx, `
        UPDATE reservations 
        SET status = $1
        WHERE id = $2`,
		model.ReservationStatusCancelled, id)
	if err != nil {
		return false, fmt.Errorf("failed to cancel reservation: %v", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return true, nil
}

// FulfillReservation implements the fulfillReservation mutation

func (r *mutationResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
    tx, err := r.DB.Begin(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to begin transaction: %v", err)
    }
    defer tx.Rollback(ctx)

    // 1. Get and lock the reservation
    var reservation model.Reservation
    var reservedAt, expiresAt time.Time
    var status string

    err = tx.QueryRow(ctx, `
        SELECT id, book_id, patron_id, book_copy_id, reserved_at, expires_at, status 
        FROM reservations 
        WHERE id = $1
        FOR UPDATE`, id).Scan(
        &reservation.ID,
        &reservation.BookID,
        &reservation.PatronID,
        &reservation.BookCopyID,
        &reservedAt,
        &expiresAt,
        &status,
    )

    if err != nil {
        if errors.Is(err, pgx.ErrNoRows) {
            return nil, &FulfillmentError{Code: "NOT_FOUND", Message: "reservation not found"}
        }
        return nil, fmt.Errorf("failed to get reservation: %v", err)
    }

    reservation.Status = model.ReservationStatus(status)
    reservation.ReservedAt = reservedAt.Format(time.RFC3339)
    reservation.ExpiresAt = expiresAt.Format(time.RFC3339)

    // 2. Validate status
    if model.ReservationStatus(status) != model.ReservationStatusPending {
        return nil, &FulfillmentError{
            Code:    "INVALID_STATUS",
            Message: fmt.Sprintf("cannot fulfill reservation with status: %s", status),
        }
    }

    // 3. Check expiration
    if time.Now().After(expiresAt) {
        if _, err = tx.Exec(ctx, `
            UPDATE reservations SET status = $1 WHERE id = $2`,
            model.ReservationStatusExpired, id,
        ); err != nil {
            return nil, fmt.Errorf("failed to mark reservation as expired: %v", err)
        }
        return nil, &FulfillmentError{
            Code:    "EXPIRED",
            Message: "reservation has expired",
        }
    }

    // 4. Update reservation status
    var updatedReservedAt, updatedExpiresAt time.Time
    err = tx.QueryRow(ctx, `
        UPDATE reservations 
        SET status = $1
        WHERE id = $2
        RETURNING reserved_at, expires_at`,
        model.ReservationStatusFulfilled, id,
    ).Scan(&updatedReservedAt, &updatedExpiresAt)
    if err != nil {
        return nil, fmt.Errorf("failed to update reservation: %v", err)
    }

    // 5. Get RabbitMQ connection for inventory update
    _, conn, _, err := services.CheckAvailability(reservation.BookID)
    if err != nil {
        return nil, fmt.Errorf("failed to get inventory connection: %v", err)
    }
    defer func() {
        if conn != nil && !conn.IsClosed() {
            conn.Close()
        }
    }()

    // 6. Update book copy status in inventory
    bookCopyIDStr := strconv.Itoa(int(reservation.BookCopyID))
    if err := services.SendUpdateRequest(conn, bookCopyIDStr, "Borrowed"); err != nil {
        return nil, fmt.Errorf("failed to update book copy status: %v", err)
    }

    // 7. Create borrow record
    now := time.Now()
    borrowRecordID := uuid.New().String()
    if _, err = tx.Exec(ctx, `
        INSERT INTO borrow_records (
            id, book_id, patron_id, book_copy_id, 
            borrowed_at, due_date, status, renewal_count
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        borrowRecordID,
        reservation.BookID,
        reservation.PatronID,
        reservation.BookCopyID,
        now,
        now.AddDate(0, 0, 14),
        model.BorrowStatusActive,
        0,
    ); err != nil {
        return nil, fmt.Errorf("failed to create borrow record: %v", err)
    }

    if err := tx.Commit(ctx); err != nil {
        return nil, fmt.Errorf("failed to commit transaction: %v", err)
    }

    // Prepare final response
    reservation.Status = model.ReservationStatusFulfilled
    reservation.ReservedAt = updatedReservedAt.Format(time.RFC3339)
    reservation.ExpiresAt = updatedExpiresAt.Format(time.RFC3339)

    return &reservation, nil
}

// BorrowRecords is the resolver for the borrowRecords field.
// BorrowRecords is the resolver for the borrowRecords field.
// BorrowRecords is the resolver for the borrowRecords field.
func (r *queryResolver) BorrowRecords(ctx context.Context, patronID *string, bookID *string, status *model.BorrowStatus) ([]*model.BorrowRecord, error) {
    // Build the query dynamically
    query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE 1=1`
    
    args := []interface{}{}
    argPos := 1

    if patronID != nil {
        query += fmt.Sprintf(" AND patron_id = $%d", argPos)
        args = append(args, *patronID)
        argPos++
    }
    if bookID != nil {
        query += fmt.Sprintf(" AND book_id = $%d", argPos)
        args = append(args, *bookID)
        argPos++
    }
    if status != nil {
        query += fmt.Sprintf(" AND status = $%d", argPos)
        args = append(args, string(*status))
        argPos++
    }

    query += " ORDER BY borrowed_at DESC"

    rows, err := r.DB.Query(ctx, query, args...)
    if err != nil {
        return nil, fmt.Errorf("failed to query borrow records: %w", err)
    }
    defer rows.Close()

    var records []*model.BorrowRecord
    for rows.Next() {
        var (
            record model.BorrowRecord
            borrowedAt, dueDate time.Time
            returnedAt, prevDueDate pgtype.Timestamptz
        )

        err := rows.Scan(
            &record.ID,
            &record.BookID,
            &record.PatronID,
            &record.BookCopyID,
            &borrowedAt,
            &dueDate,
            &returnedAt,
            &record.RenewalCount,
            &record.Status,
            &prevDueDate,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan record: %w", err)
        }

        // Convert timestamps
        record.BorrowedAt = borrowedAt.Format(time.RFC3339)
        record.DueDate = dueDate.Format(time.RFC3339)
        
        if returnedAt.Valid {
            returnedStr := returnedAt.Time.Format(time.RFC3339)
            record.ReturnedAt = &returnedStr
        }
        if prevDueDate.Valid {
            prevDueStr := prevDueDate.Time.Format(time.RFC3339)
            record.PreviousDueDate = &prevDueStr
        }

        records = append(records, &record)
    }

    return records, nil
}

// Reservations is the resolver for the reservations field.
func (r *queryResolver) Reservations(ctx context.Context, patronID *string, bookID *string, status *model.ReservationStatus) ([]*model.Reservation, error) {
    query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            reserved_at, expires_at, status
        FROM reservations 
        WHERE 1=1`
    
    args := []interface{}{}
    argPos := 1

    if patronID != nil {
        query += fmt.Sprintf(" AND patron_id = $%d", argPos)
        args = append(args, *patronID)
        argPos++
    }
    if bookID != nil {
        query += fmt.Sprintf(" AND book_id = $%d", argPos)
        args = append(args, *bookID)
        argPos++
    }
    if status != nil {
        query += fmt.Sprintf(" AND status = $%d", argPos)
        args = append(args, string(*status))
        argPos++
    }

    query += " ORDER BY reserved_at DESC"

    rows, err := r.DB.Query(ctx, query, args...)
    if err != nil {
        return nil, fmt.Errorf("failed to query reservations: %w", err)
    }
    defer rows.Close()

    var reservations []*model.Reservation
    for rows.Next() {
        var res model.Reservation
        var reservedAt, expiresAt time.Time

        err := rows.Scan(
            &res.ID,
            &res.BookID,
            &res.PatronID,
            &res.BookCopyID,
            &reservedAt,
            &expiresAt,
            &res.Status,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan reservation: %w", err)
        }

        res.ReservedAt = reservedAt.Format(time.RFC3339)
        res.ExpiresAt = expiresAt.Format(time.RFC3339)
        reservations = append(reservations, &res)
    }

    return reservations, nil
}

// OverdueRecords is the resolver for the overdueRecords field.
func (r *queryResolver) OverdueRecords(ctx context.Context) ([]*model.BorrowRecord, error) {
    query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE status = $1 
        AND due_date < NOW()
        ORDER BY due_date ASC`

    rows, err := r.DB.Query(ctx, query, string(model.BorrowStatusActive))
    if err != nil {
        return nil, fmt.Errorf("failed to query overdue records: %w", err)
    }
    defer rows.Close()

    var records []*model.BorrowRecord
    for rows.Next() {
        var (
            record model.BorrowRecord
            borrowedAt, dueDate time.Time
            returnedAt, prevDueDate pgtype.Timestamptz
        )

        err := rows.Scan(
            &record.ID,
            &record.BookID,
            &record.PatronID,
            &record.BookCopyID,
            &borrowedAt,
            &dueDate,
            &returnedAt,
            &record.RenewalCount,
            &record.Status,
            &prevDueDate,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan record: %w", err)
        }

        record.BorrowedAt = borrowedAt.Format(time.RFC3339)
        record.DueDate = dueDate.Format(time.RFC3339)
        
        if returnedAt.Valid {
            returnedStr := returnedAt.Time.Format(time.RFC3339)
            record.ReturnedAt = &returnedStr
        }
        if prevDueDate.Valid {
            prevDueStr := prevDueDate.Time.Format(time.RFC3339)
            record.PreviousDueDate = &prevDueStr
        }

        records = append(records, &record)
    }

    return records, nil
}

// PatronBorrowHistory is the resolver for the patronBorrowHistory field.
func (r *queryResolver) PatronBorrowHistory(ctx context.Context, patronID string) ([]*model.BorrowRecord, error) {
    query := `
        SELECT 
            id, book_id, patron_id, book_copy_id,
            borrowed_at, due_date, returned_at,
            renewal_count, status, previous_due_date
        FROM borrow_records 
        WHERE patron_id = $1
        ORDER BY borrowed_at DESC`

    rows, err := r.DB.Query(ctx, query, patronID)
    if err != nil {
        return nil, fmt.Errorf("failed to query patron history: %w", err)
    }
    defer rows.Close()

    var records []*model.BorrowRecord
    for rows.Next() {
        var (
            record model.BorrowRecord
            borrowedAt, dueDate time.Time
            returnedAt, prevDueDate pgtype.Timestamptz
        )

        err := rows.Scan(
            &record.ID,
            &record.BookID,
            &record.PatronID,
            &record.BookCopyID,
            &borrowedAt,
            &dueDate,
            &returnedAt,
            &record.RenewalCount,
            &record.Status,
            &prevDueDate,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan record: %w", err)
        }

        record.BorrowedAt = borrowedAt.Format(time.RFC3339)
        record.DueDate = dueDate.Format(time.RFC3339)
        
        if returnedAt.Valid {
            returnedStr := returnedAt.Time.Format(time.RFC3339)
            record.ReturnedAt = &returnedStr
        }
        if prevDueDate.Valid {
            prevDueStr := prevDueDate.Time.Format(time.RFC3339)
            record.PreviousDueDate = &prevDueStr
        }

        records = append(records, &record)
    }

    return records, nil
}


// ReservationCreated implements SubscriptionResolver.
func (r *subscriptionResolver) ReservationCreated(ctx context.Context, bookID string) (<-chan *model.Reservation, error) {
	updates := make(chan *model.Reservation)

	go func() {
		defer close(updates)

		for {
			select {
			case <-ctx.Done():
				return
			case <-time.After(5 * time.Second): // Simulate an update every 5 seconds
				updates <- &model.Reservation{
					ID:         "example-reservation-id",
					BookID:     bookID,
					PatronID:   "example-patron-id",
					BookCopyID: 1, // Added bookCopyId
					ReservedAt: time.Now().Format(time.RFC3339),
					ExpiresAt:  time.Now().AddDate(0, 0, 3).Format(time.RFC3339),
					Status:     model.ReservationStatusPending,
				}
			}
		}
	}()

	return updates, nil
}

// BorrowRecordUpdated implements SubscriptionResolver.
func (r *subscriptionResolver) BorrowRecordUpdated(ctx context.Context, patronID string) (<-chan *model.BorrowRecord, error) {
	updates := make(chan *model.BorrowRecord)

	go func() {
		defer close(updates)

		// Simulate listening to updates for the given patronID
		// Replace this with actual implementation, e.g., listening to a message queue or database changes
		for {
			select {
			case <-ctx.Done():
				return
			case <-time.After(5 * time.Second): // Simulate an update every 5 seconds
				updates <- &model.BorrowRecord{
					ID:         "example-id",
					BookID:     "example-book-id",
					PatronID:   patronID,
					BorrowedAt: time.Now().Format(time.RFC3339),
					DueDate:    time.Now().AddDate(0, 0, 14).Format(time.RFC3339),
					Status:     model.BorrowStatusActive,
				}
			}
		}
	}()

	return updates, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/Cat6utpcableclarke/API-gateway/graph/model"
	amqp "github.com/rabbitmq/amqp091-go"
)

// AddBook is the resolver for the addBook field.
func (r *mutationResolver) AddBook(ctx context.Context, title string, authorName string, datePublished string, description string) (*model.Book, error) {
	query := `
        mutation AddBook($title: String!, $author_name: String!, $datePublished: String!, $description: String!) {
            addBook(title: $title, author_name: $author_name, datePublished: $datePublished, description: $description) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"title":         title,
		"author_name":   authorName,
		"datePublished": datePublished,
		"description":   description,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			AddBook *model.Book `json:"addBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.AddBook, nil
}

// AddBCopy is the resolver for the addBCopy field.
func (r *mutationResolver) AddBCopy(ctx context.Context, bookID string) (*model.BookCopies, error) {
	query := `
        mutation AddBCopy($bookID: String!) {
            addBCopy(bookID: $bookID) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"bookID": bookID,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			AddBCopy *model.BookCopies `json:"addBCopy"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.AddBCopy, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, title string, authorName *string, datePublished *string, description *string) (*model.Book, error) {
	query := `
        mutation UpdateBook($id: String!, $title: String!, $author_name: String, $datePublished: String, $description: String) {
            updateBook(id: $id, title: $title, author_name: $author_name, datePublished: $datePublished, description: $description) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"id":            id,
		"title":         title,
		"author_name":   authorName,
		"datePublished": datePublished,
		"description":   description,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			UpdateBook *model.Book `json:"updateBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdateBook, nil
}

// UpdateBookCopyStatus is the resolver for the updateBookCopyStatus field.
func (r *mutationResolver) UpdateBookCopyStatus(ctx context.Context, id string, bookStatus *string) (*model.BookCopies, error) {
	query := `
        mutation UpdateBookCopyStatus($id: ID!, $bookStatus: String) {
            updateBookCopyStatus(id: $id, book_status: $bookStatus) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id":         id,
		"bookStatus": bookStatus,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			UpdateBookCopyStatus *model.BookCopies `json:"updateBookCopyStatus"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdateBookCopyStatus, nil
}

// DeleteBCopy is the resolver for the deleteBCopy field.
func (r *mutationResolver) DeleteBCopy(ctx context.Context, id string) (bool, error) {
	query := `
        mutation DeleteBCopy($id: String!) {
            deleteBCopy(id: $id)
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return false, err
	}

	var result struct {
		Data struct {
			DeleteBCopy bool `json:"deleteBCopy"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeleteBCopy, nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	query := `
        mutation DeleteBook($id: String!) {
            deleteBook(id: $id)
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return false, err
	}

	var result struct {
		Data struct {
			DeleteBook bool `json:"deleteBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeleteBook, nil
}

// CreatePatron is the resolver for the createPatron field.
func (r *mutationResolver) CreatePatron(ctx context.Context, firstName string, lastName string, phoneNumber string, email string, password string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"firstName":   firstName,
		"lastName":    lastName,
		"phoneNumber": phoneNumber,
		"email":       email,
		"password":    password,
	}

	//resp, err := forwardRequest(ctx, query, variables, patronServiceURL)
	resp, err := forwardRequestMQ(patronServiceQueue, variables, "createPatron")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			CreatePatron *model.Patron `json:"createPatron"`
		} `json:"data"`
	}
	// log.Printf("in createpatron: %s", resp)
	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	// log.Printf("check unmarshal: %+v", result.Data.CreatePatron)

	return result.Data.CreatePatron, nil
}

// UpdatePatron is the resolver for the updatePatron field.
func (r *mutationResolver) UpdatePatron(ctx context.Context, patronID string, firstName *string, lastName *string, phoneNumber *string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id":   patronID,
		"firstName":   firstName,
		"lastName":    lastName,
		"phoneNumber": phoneNumber,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updatePatron")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdatePatron *model.Patron `json:"updatePatron"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdatePatron, nil
}

// DeletePatronByID is the resolver for the deletePatronById field.
func (r *mutationResolver) DeletePatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "deletePatronById")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			DeletePatronByID *model.Patron `json:"deletePatronById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeletePatronByID, nil
}

// UpdateMembershipByPatronID is the resolver for the updateMembershipByPatronId field.
func (r *mutationResolver) UpdateMembershipByPatronID(ctx context.Context, patronID string, level model.MembershipLevel) (*model.Membership, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
		"level":     level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updateMembershipByPatronId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdateMembershipByPatronID *model.Membership `json:"updateMembershipByPatronId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdateMembershipByPatronID, nil
}

// UpdateMembershipByMembershipID is the resolver for the updateMembershipByMembershipId field.
func (r *mutationResolver) UpdateMembershipByMembershipID(ctx context.Context, membershipID string, level model.MembershipLevel) (*model.Membership, error) {
	variables := map[string]interface{}{
		"membership_id": membershipID,
		"level":         level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updateMembershipByMembershipId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdateMembershipByMembershipID *model.Membership `json:"updateMembershipByMembershipId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdateMembershipByMembershipID, nil
}

// UpdatePatronStatus is the resolver for the updatePatronStatus field.
func (r *mutationResolver) UpdatePatronStatus(ctx context.Context, patronID string, warningCount *int32, unpaidFees *float64, patronStatus *model.Status) (*model.PatronStatus, error) {
	variables := map[string]interface{}{
		"patron_id":     patronID,
		"warning_count": warningCount,
		"unpaid_fees":   unpaidFees,
		"status":        patronStatus,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updatePatronStatus")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdatePatronStatus *model.PatronStatus `json:"updatePatronStatus"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdatePatronStatus, nil
}

// BorrowBook is the resolver for the borrowBook field.
func (r *mutationResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	query := `
	mutation BorrowBook($bookId: ID!, $patronId: ID!) {
		borrowBook(bookId: $bookId, patronId: $patronId) {
			id
			bookId
			patronId
			borrowedAt
			dueDate
			returnedAt
			renewalCount
			previousDueDate
			status
			bookCopyId
		}
	}
`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	// Assuming you have a lendingServiceURL constant defined
	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			BorrowBook *model.BorrowRecord `json:"borrowBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.BorrowBook, nil
}

// ReturnBook is the resolver for the returnBook field.
func (r *mutationResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	query := `
	mutation ReturnBook($recordId: ID!) {
		returnBook(recordId: $recordId) {
			id
			bookId
			patronId
			borrowedAt
			dueDate
			returnedAt
			renewalCount
			previousDueDate
			status
			bookCopyId
		}
	}
`

	variables := map[string]interface{}{
		"recordId": recordID,
	}

	// Assuming you have a lendingServiceURL constant defined
	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			ReturnBook *model.BorrowRecord `json:"returnBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.ReturnBook, nil
}

// RenewLoan is the resolver for the renewLoan field.
func (r *mutationResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	query := `
    mutation RenewLoan($recordId: ID!) {
        renewLoan(recordId: $recordId) {
            __typename
            ... on RenewalError {
                code
                message
            }
            ... on BorrowRecord {
                id
                bookId
                patronId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                bookCopyId
            }
        }
    }`

	variables := map[string]interface{}{
		"recordId": recordID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to renew loan: %v", err)
	}

	var result struct {
		Data struct {
			RenewLoan model.RenewLoanResult `json:"renewLoan"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse renewal response: %v", err)
	}

	return result.Data.RenewLoan, nil
}

// ReserveBook is the resolver for the reserveBook field.
func (r *mutationResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	query := `
    mutation ReserveBook($bookId: ID!, $patronId: ID!) {
        reserveBook(bookId: $bookId, patronId: $patronId) {
            id
            bookId
            patronId
            reservedAt
            status
            expiresAt
        }
    }`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		// Handle specific error cases
		if strings.Contains(err.Error(), "BOOK_NOT_AVAILABLE") {
			return nil, fmt.Errorf("this book is currently not available for reservation")
		}
		if strings.Contains(err.Error(), "PATRON_LIMIT_REACHED") {
			return nil, fmt.Errorf("patron has reached maximum allowed reservations")
		}
		return nil, fmt.Errorf("reservation failed: %v", err)
	}

	var result struct {
		Data struct {
			ReserveBook *model.Reservation `json:"reserveBook"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf(result.Errors[0].Message)
	}

	return result.Data.ReserveBook, nil
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	query := `
    mutation CancelReservation($id: ID!) {
        cancelReservation(id: $id)
    }`

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return false, fmt.Errorf("failed to cancel reservation: %v", err)
	}

	var result struct {
		Data struct {
			CancelReservation bool `json:"cancelReservation"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to parse cancellation response: %v", err)
	}

	return result.Data.CancelReservation, nil
}

// FulfillReservation is the resolver for the fulfillReservation field.
// FulfillReservation is the resolver for the fulfillReservation field.
func (r *mutationResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	query := `
        mutation FulfillReservation($id: ID!) {
            fulfillReservation(id: $id) {
                id
                bookId
                patronId
                bookCopyId
                reservedAt
                expiresAt
                status
            }
        }`

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fulfill reservation: %v", err)
	}

	// Parse the response
	var result struct {
		Data struct {
			FulfillReservation *model.Reservation `json:"fulfillReservation"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse fulfillment response: %v", err)
	}

	// Handle GraphQL errors
	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.FulfillReservation, nil
}

// GetBooks is the resolver for the getBooks field.
func (r *queryResolver) GetBooks(ctx context.Context) ([]*model.Book, error) {
	query := `
        query {
            getBooks {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	resp, err := forwardRequest(ctx, query, nil, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBooks []*model.Book `json:"getBooks"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBooks, nil
}

// GetBookByID is the resolver for the getBookById field.
func (r *queryResolver) GetBookByID(ctx context.Context, id string) (*model.Book, error) {
	query := `
        query GetBookById($id: String!) {
            getBookById(id: $id) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookById *model.Book `json:"getBookById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookById, nil
}

// GetBookCopiesByID is the resolver for the getBookCopiesById field.
func (r *queryResolver) GetBookCopiesByID(ctx context.Context, id string) ([]*model.BookCopies, error) {
	query := `
        query GetBookCopiesById($id: String!) {
            getBookCopiesById(id: $id) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookCopiesById []*model.BookCopies `json:"getBookCopiesById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookCopiesById, nil
}

// SearchBooks is the resolver for the searchBooks field.
func (r *queryResolver) SearchBooks(ctx context.Context, query string) ([]*model.Book, error) {
	searchQuery := `
        query SearchBooks($query: String!) {
            searchBooks(query: $query) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"query": query,
	}

	resp, err := forwardRequest(ctx, searchQuery, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			SearchBooks []*model.Book `json:"searchBooks"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.SearchBooks, nil
}

// GetAvailbleBookCopyByID is the resolver for the GetAvailbleBookCopyByID field.
func (r *queryResolver) GetAvailbleBookCopyByID(ctx context.Context, id string) (*model.BookCopies, error) {
	query := `
        query GetAvailbleBookCopyByID($id: String!) {
            getAvailbleBookCopyByID(id: $id) {
                id
                book_id
                title
                author_name
                date_published
                description
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	// Forward the request to the Book Service
	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	// Parse the response
	var result struct {
		Data struct {
			GetAvailbleBookCopyByID *model.BookCopies `json:"getAvailbleBookCopyByID"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetAvailbleBookCopyByID, nil
}

// GetPatronByID is the resolver for the getPatronById field.
func (r *queryResolver) GetPatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getPatronById")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetPatronByID *model.Patron `json:"getPatronById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetPatronByID, nil
}

// GetAllPatrons is the resolver for the getAllPatrons field.
func (r *queryResolver) GetAllPatrons(ctx context.Context) ([]*model.Patron, error) {
	variables := map[string]interface{}{}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getAllPatrons")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetAllPatrons []*model.Patron `json:"getAllPatrons"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetAllPatrons, nil
}

// GetMembershipByLevel is the resolver for the getMembershipByLevel field.
func (r *queryResolver) GetMembershipByLevel(ctx context.Context, level model.MembershipLevel) ([]*model.Membership, error) {
	variables := map[string]interface{}{
		"level": level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getMembershipByLevel")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetMembershipByLevel []*model.Membership `json:"getMembershipByLevel"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetMembershipByLevel, nil
}

// GetMembershipByPatronID is the resolver for the getMembershipByPatronId field.
func (r *queryResolver) GetMembershipByPatronID(ctx context.Context, patronID string) (*model.Membership, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getMembershipByPatronId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetMembershipByPatronID *model.Membership `json:"getMembershipByPatronId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetMembershipByPatronID, nil
}

// GetPatronStatusByType is the resolver for the getPatronStatusByType field.
func (r *queryResolver) GetPatronStatusByType(ctx context.Context, patronStatus model.Status) ([]*model.PatronStatus, error) {
	variables := map[string]interface{}{
		"status": patronStatus,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getPatronStatusByType")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetPatronStatusByType []*model.PatronStatus `json:"getPatronStatusByType"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetPatronStatusByType, nil
}

// BorrowRecords is the resolver for the borrowRecords field.
func (r *queryResolver) BorrowRecords(ctx context.Context, patronID *string, bookID *string, status *model.BorrowStatus) ([]*model.BorrowRecord, error) {
	query := `
        query BorrowRecords($patronID: String, $bookID: String, $status: BorrowStatus) {
            borrowRecords(patronID: $patronID, bookID: $bookID, status: $status) {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	variables := map[string]interface{}{
		"patronID": patronID,
		"bookID":   bookID,
		"status":   status,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch borrow records: %v", err)
	}

	var result struct {
		Data struct {
			BorrowRecords []*model.BorrowRecord `json:"borrowRecords"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.BorrowRecords, nil
}

// Reservations is the resolver for the reservations field.
func (r *queryResolver) Reservations(ctx context.Context, patronID *string, bookID *string, status *model.ReservationStatus) ([]*model.Reservation, error) {
	query := `
        query Reservations($patronID: String, $bookID: String, $status: ReservationStatus) {
            reservations(patronID: $patronID, bookID: $bookID, status: $status) {
                id
                bookId
                patronId
                bookCopyId
                reservedAt
                expiresAt
                status
            }
        }`

	variables := map[string]interface{}{
		"patronID": patronID,
		"bookID":   bookID,
		"status":   status,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reservations: %v", err)
	}

	var result struct {
		Data struct {
			Reservations []*model.Reservation `json:"reservations"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.Reservations, nil
}

// OverdueRecords is the resolver for the overdueRecords field.
func (r *queryResolver) OverdueRecords(ctx context.Context) ([]*model.BorrowRecord, error) {
	query := `
        query {
            overdueRecords {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	resp, err := forwardRequest(ctx, query, nil, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch overdue records: %v", err)
	}

	var result struct {
		Data struct {
			OverdueRecords []*model.BorrowRecord `json:"overdueRecords"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.OverdueRecords, nil
}

// PatronBorrowHistory is the resolver for the patronBorrowHistory field.
func (r *queryResolver) PatronBorrowHistory(ctx context.Context, patronID string) ([]*model.BorrowRecord, error) {
	query := `
        query PatronBorrowHistory($patronID: String!) {
            patronBorrowHistory(patronID: $patronID) {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	variables := map[string]interface{}{
		"patronID": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch patron history: %v", err)
	}

	var result struct {
		Data struct {
			PatronBorrowHistory []*model.BorrowRecord `json:"patronBorrowHistory"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.PatronBorrowHistory, nil
}

// BorrowBook is the resolver for the borrowBook field.
func (r *queryResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: BorrowBook - borrowBook"))
}

// ReturnBook is the resolver for the returnBook field.
func (r *queryResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: ReturnBook - returnBook"))
}

// RenewLoan is the resolver for the renewLoan field.
func (r *queryResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	panic(fmt.Errorf("not implemented: RenewLoan - renewLoan"))
}

// ReserveBook is the resolver for the reserveBook field.
func (r *queryResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	panic(fmt.Errorf("not implemented: ReserveBook - reserveBook"))
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *queryResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: CancelReservation - cancelReservation"))
}

// FulfillReservation is the resolver for the fulfillReservation field.
func (r *queryResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	panic(fmt.Errorf("not implemented: FulfillReservation - fulfillReservation"))
}

// BookAdded is the resolver for the bookAdded field.
func (r *subscriptionResolver) BookAdded(ctx context.Context) (<-chan *model.Book, error) {
	bookChan := make(chan *model.Book)
	err := SubscribeToBookAdded(ctx, bookChan)
	if err != nil {
		return nil, err
	}
	return bookChan, nil
}

// PatronCreated is the resolver for the patronCreated field.
func (r *subscriptionResolver) PatronCreated(ctx context.Context) (<-chan *model.Patron, error) {
	patronChan := make(chan *model.Patron)

	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	ch, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	_, err = ch.QueueDeclare(
		"patron-subscription-patronChan-queue",
		false,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to declare queue: %w", err)
	}

	msgs, err := ch.Consume(
		"patron-subscription-patronChan-queue",
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to consume: %w", err)
	}

	go func() {
		defer ch.Close()
		defer conn.Close()

		for {
			select {
			case <-ctx.Done():
				close(patronChan)
				return
			case msg := <-msgs:
				var response struct {
					Data struct {
						CreatePatron *model.Patron `json:"createPatron"`
					} `json:"data"`
				}

				if err := json.Unmarshal(msg.Body, &response); err == nil {
					patronChan <- response.Data.CreatePatron
				}
			}
		}
	}()

	return patronChan, nil
}

// PatronStatusUpdated is the resolver for the patronStatusUpdated field.
func (r *subscriptionResolver) PatronStatusUpdated(ctx context.Context) (<-chan *model.PatronStatus, error) {
	patronUpdatesChan := make(chan *model.PatronStatus)

	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	ch, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	_, err = ch.QueueDeclare(
		"patron-subscription-updatesChan-queue",
		false,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to declare queue: %w", err)
	}

	msgs, err := ch.Consume(
		"patron-subscription-updatesChan-queue",
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to consume: %w", err)
	}

	go func() {
		defer ch.Close()
		defer conn.Close()

		for {
			select {
			case <-ctx.Done():
				close(patronUpdatesChan)
				return
			case msg := <-msgs:
				var response struct {
					Data struct {
						PatronStatusUpdate *model.PatronStatus `json:"updatePatronStatus"`
					} `json:"data"`
				}

				if err := json.Unmarshal(msg.Body, &response); err == nil {
					patronUpdatesChan <- response.Data.PatronStatusUpdate
				}
			}
		}
	}()

	return patronUpdatesChan, nil
}

// ReservationCreated is the resolver for the reservationCreated field.
func (r *subscriptionResolver) ReservationCreated(ctx context.Context) (<-chan *model.Reservation, error) {
	panic(fmt.Errorf("not implemented: ReservationCreated - reservationCreated"))
}

// BorrowRecordUpdated is the resolver for the borrowRecordUpdated field.
func (r *subscriptionResolver) BorrowRecordUpdated(ctx context.Context) (<-chan *model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: BorrowRecordUpdated - borrowRecordUpdated"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

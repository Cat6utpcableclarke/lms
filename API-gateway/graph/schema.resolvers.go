package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"

	"github.com/Cat6utpcableclarke/API-gateway/graph/model"
	"github.com/coder/websocket"
)

const bookServiceURL = "http://localhost:8080/query" // Replace with your bookService URL

// AddBook is the resolver for the addBook field.
func (r *mutationResolver) AddBook(ctx context.Context, title string, authorName string, datePublished string, description string) (*model.Book, error) {
	query := `
        mutation AddBook($title: String!, $author_name: String!, $datePublished: String!, $description: String!) {
            addBook(title: $title, author_name: $author_name, datePublished: $datePublished, description: $description) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"title":         title,
		"author_name":   authorName,
		"datePublished": datePublished,
		"description":   description,
	}

	resp, err := forwardRequest(ctx, query, variables)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			AddBook *model.Book `json:"addBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.AddBook, nil
}

// GetBooks is the resolver for the getBooks field.
func (r *queryResolver) GetBooks(ctx context.Context) ([]*model.Book, error) {
	query := `
        query {
            getBooks {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	resp, err := forwardRequest(ctx, query, nil)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBooks []*model.Book `json:"getBooks"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBooks, nil
}

// GetBookByID is the resolver for the getBookById field.
func (r *queryResolver) GetBookByID(ctx context.Context, id string) (*model.Book, error) {
	query := `
        query GetBookById($id: String!) {
            getBookById(id: $id) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookById *model.Book `json:"getBookById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookById, nil
}

// GetBookCopiesByID is the resolver for the getBookCopiesById field.
func (r *queryResolver) GetBookCopiesByID(ctx context.Context, id string) ([]*model.BookCopies, error) {
	query := `
        query GetBookCopiesById($id: String!) {
            getBookCopiesById(id: $id) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookCopiesById []*model.BookCopies `json:"getBookCopiesById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookCopiesById, nil
}

// BookAdded is the resolver for the bookAdded field.
func (r *subscriptionResolver) BookAdded(ctx context.Context) (<-chan *model.Book, error) {
	bookChan := make(chan *model.Book)
	err := SubscribeToBookAdded(ctx, bookChan)
	if err != nil {
		return nil, err
	}
	return bookChan, nil
}

// Helper function to forward requests to the bookService
func forwardRequest(ctx context.Context, query string, variables map[string]interface{}) ([]byte, error) {
	body := map[string]interface{}{
		"query":     query,
		"variables": variables,
	}

	jsonBody, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %v", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", bookServiceURL, bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("received non-200 response: %d", resp.StatusCode)
	}

	return io.ReadAll(resp.Body)
}

func SubscribeToBookAdded(ctx context.Context, out chan<- *model.Book) error {
	c, _, err := websocket.Dial(ctx, "ws://localhost:8080/query", nil)
	if err != nil {
		return err
	}

	// connection_init
	if err := c.Write(ctx, websocket.MessageText, []byte(`{"type":"connection_init"}`)); err != nil {
		return err
	}
	_, _, _ = c.Read(ctx) // wait for ack

	// send subscription
	payload := map[string]interface{}{
		"id":   "1",
		"type": "start",
		"payload": map[string]interface{}{
			"query": `subscription { bookAdded { id title author_name date_published description } }`,
		},
	}
	msg, _ := json.Marshal(payload)
	if err := c.Write(ctx, websocket.MessageText, msg); err != nil {
		return err
	}

	go func() {
		for {
			_, data, err := c.Read(ctx)
			if err != nil {
				log.Println("WebSocket read failed:", err)
				close(out)
				return
			}

			var msg struct {
				Type    string `json:"type"`
				Payload struct {
					Data struct {
						BookAdded *model.Book `json:"bookAdded"`
					} `json:"data"`
				} `json:"payload"`
			}
			if err := json.Unmarshal(data, &msg); err != nil {
				log.Println("Failed to unmarshal message:", err)
				continue
			}

			if msg.Type == "data" {
				out <- msg.Payload.Data.BookAdded
			}
		}
	}()

	return nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// subscribeToBookAdded is a placeholder function for subscription logic.
